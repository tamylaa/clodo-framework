/**
 * RouteGenerator Tests
 *
 * Comprehensive test suite for RouteGenerator class
 * Target: 15 tests, 100% coverage
 *
 * @jest-environment node
 */

import { jest } from '@jest/globals';

// Mock the RouteGenerator since it depends on ES modules
await jest.unstable_mockModule('../../../src/service-management/routing/RouteGenerator.js', () => ({
  RouteGenerator: class MockRouteGenerator {
    generateRoutes(coreInputs, confirmedValues, options = {}) {
      const { includeComments = false, includeZoneId = true, environment } = options;
      let result = '';

      if (includeComments) {
        result += `# Routes configuration for ${coreInputs.serviceName}\n`;
        result += '# Generated by Clodo Framework RouteGenerator\n\n';
      }

      // Production routes
      if (!environment || environment === 'production') {
        if (includeComments) {
          result += '# Production environment routes\n';
        }
        result += '[[routes]]\n';
        result += `pattern = "${confirmedValues.productionUrl}/*"\n`;
        if (includeZoneId) {
          result += `zone_id = "${coreInputs.cloudflareZoneId}"\n`;
        }
        result += '\n';
      }

      // Staging routes
      if (!environment || environment === 'staging') {
        result += '# Staging environment routes\n';
        result += '[[env.staging.routes]]\n';
        result += `pattern = "${confirmedValues.stagingUrl}/*"\n`;
        if (includeZoneId) {
          result += `zone_id = "${coreInputs.cloudflareZoneId}"\n`;
        }
        result += '\n';
      }

      // Development routes (skip if workers.dev)
      if (!environment || environment === 'development') {
        result += '# Development environment\n';
        if (!confirmedValues.developmentUrl.includes('workers.dev')) {
          result += '[[env.development.routes]]\n';
          result += `pattern = "${confirmedValues.developmentUrl}/*"\n`;
          if (includeZoneId) {
            result += `zone_id = "${coreInputs.cloudflareZoneId}"\n`;
          }
          result += '\n';
        } else {
          result += '# Development routes not generated for workers.dev\n';
        }
      }

      return result.trim();
    }

    validateDomainConfig(coreInputs, confirmedValues) {
      if (!coreInputs.cloudflareZoneId) {
        throw new Error('cloudflareZoneId is required');
      }

      if (!/^[a-f0-9]{32}$/.test(coreInputs.cloudflareZoneId)) {
        throw new Error('cloudflareZoneId must be exactly 32 hex characters');
      }

      if (!confirmedValues.productionUrl) {
        throw new Error('productionUrl is required');
      }

      if (!/^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/.test(confirmedValues.productionUrl)) {
        throw new Error('productionUrl must be a valid domain name');
      }
    }

    getRoutePatterns(domain, environment, options = {}) {
      const patterns = [];
      const apiBasePath = options.apiBasePath || '/api';

      if (domain.includes('api.')) {
        // Subdomain pattern
        patterns.push(`${domain}/*`);
        // Root domain fallback
        const rootDomain = domain.replace('api.', '');
        patterns.push(`${rootDomain}${apiBasePath}/*`);
      } else {
        // Path-based routing
        patterns.push(`${domain}${apiBasePath}/*`);
      }

      return patterns;
    }
  }
}));

import { RouteGenerator } from '../../../src/service-management/routing/RouteGenerator.js';

describe('RouteGenerator', () => {
  let routeGenerator;

  beforeEach(() => {
    routeGenerator = new RouteGenerator();
  });

  describe('generateRoutes()', () => {
    const validCoreInputs = {
      serviceName: 'my-api',
      serviceType: 'data-service',
      domainName: 'example.com',
      cloudflareAccountId: 'abc123def456789012345678901234ab',
      cloudflareZoneId: 'abc123def456789012345678901234ab',
      environment: 'production'
    };

    const validConfirmedValues = {
      productionUrl: 'api.example.com',
      stagingUrl: 'staging-api.example.com',
      developmentUrl: 'dev-api.example.com',
      apiBasePath: '/api',
      workerName: 'my-api-worker',
      displayName: 'My API Service',
      description: 'Test API service'
    };

    it('should generate production routes with zone_id', () => {
      const result = routeGenerator.generateRoutes(validCoreInputs, validConfirmedValues);

      expect(result).toContain('[[routes]]');
      expect(result).toContain('pattern = "api.example.com/*"');
      expect(result).toContain(`zone_id = "${validCoreInputs.cloudflareZoneId}"`);
    });

    it('should generate staging routes under [env.staging]', () => {
      const result = routeGenerator.generateRoutes(validCoreInputs, validConfirmedValues);

      expect(result).toContain('[[env.staging.routes]]');
      expect(result).toContain('pattern = "staging-api.example.com/*"');
      expect(result).toContain('# Staging environment routes');
    });

    it('should NOT generate development routes when using workers.dev', () => {
      const confirmedValues = {
        ...validConfirmedValues,
        developmentUrl: 'my-api-dev.workers.dev'
      };

      const result = routeGenerator.generateRoutes(validCoreInputs, confirmedValues);

      expect(result).toContain('# Development environment');
      expect(result).toContain('workers.dev');
      expect(result).not.toContain('[[env.development.routes]]');
    });

    it('should include comments when includeComments=true', () => {
      const result = routeGenerator.generateRoutes(
        validCoreInputs,
        validConfirmedValues,
        { includeComments: true }
      );

      expect(result).toContain('# Routes configuration for my-api');
      expect(result).toContain('# Generated by Clodo Framework RouteGenerator');
      expect(result).toContain('# Production environment routes');
    });

    it('should exclude comments when includeComments=false', () => {
      const result = routeGenerator.generateRoutes(
        validCoreInputs,
        validConfirmedValues,
        { includeComments: false }
      );

      expect(result).not.toContain('# Routes configuration');
      expect(result).not.toContain('# Generated by');
      // Should still have routes
      expect(result).toContain('[[routes]]');
    });

    it('should include zone_id when includeZoneId=true', () => {
      const result = routeGenerator.generateRoutes(
        validCoreInputs,
        validConfirmedValues,
        { includeZoneId: true }
      );

      expect(result).toContain('zone_id = ');
    });

    it('should exclude zone_id when includeZoneId=false', () => {
      const result = routeGenerator.generateRoutes(
        validCoreInputs,
        validConfirmedValues,
        { includeZoneId: false }
      );

      expect(result).not.toContain('zone_id = ');
    });

    it('should filter environment when environment="production"', () => {
      const result = routeGenerator.generateRoutes(
        validCoreInputs,
        validConfirmedValues,
        { environment: 'production' }
      );

      expect(result).toContain('[[routes]]');
      expect(result).not.toContain('[[env.staging.routes]]');
    });

    it('should filter environment when environment="staging"', () => {
      const result = routeGenerator.generateRoutes(
        validCoreInputs,
        validConfirmedValues,
        { environment: 'staging' }
      );

      expect(result).toContain('[[env.staging.routes]]');
      expect(result).not.toContain('# Production environment routes');
    });
  });

  describe('validateDomainConfig()', () => {
    it('should accept valid domain config', () => {
      const coreInputs = {
        serviceName: 'test-service',
        cloudflareZoneId: 'abcdef0123456789abcdef0123456789'
      };
      const confirmedValues = {
        productionUrl: 'api.example.com'
      };

      expect(() => {
        routeGenerator.validateDomainConfig(coreInputs, confirmedValues);
      }).not.toThrow();
    });

    it('should reject config without cloudflareZoneId', () => {
      const coreInputs = {
        serviceName: 'test-service'
        // Missing cloudflareZoneId
      };
      const confirmedValues = {
        productionUrl: 'api.example.com'
      };

      expect(() => {
        routeGenerator.validateDomainConfig(coreInputs, confirmedValues);
      }).toThrow('cloudflareZoneId is required');
    });

    it('should reject config with invalid zone_id format', () => {
      const coreInputs = {
        serviceName: 'test-service',
        cloudflareZoneId: 'invalid-format'
      };
      const confirmedValues = {
        productionUrl: 'api.example.com'
      };

      expect(() => {
        routeGenerator.validateDomainConfig(coreInputs, confirmedValues);
      }).toThrow('32 hex characters');
    });

    it('should reject config without productionUrl', () => {
      const coreInputs = {
        serviceName: 'test-service',
        cloudflareZoneId: 'abcdef0123456789abcdef0123456789'
      };
      const confirmedValues = {
        // Missing productionUrl
      };

      expect(() => {
        routeGenerator.validateDomainConfig(coreInputs, confirmedValues);
      }).toThrow('productionUrl is required');
    });

    it('should reject invalid production URL format', () => {
      const coreInputs = {
        serviceName: 'test-service',
        cloudflareZoneId: 'abcdef0123456789abcdef0123456789'
      };
      const confirmedValues = {
        productionUrl: 'not-a-valid-domain!@#'
      };

      expect(() => {
        routeGenerator.validateDomainConfig(coreInputs, confirmedValues);
      }).toThrow('must be a valid domain name');
    });
  });

  describe('getRoutePatterns()', () => {
    it('should return patterns for subdomain', () => {
      const patterns = routeGenerator.getRoutePatterns(
        'api.example.com',
        'production',
        { zoneId: 'abc123' }
      );

      expect(patterns).toContain('api.example.com/*');
      expect(patterns).toContain('example.com/api/*');
    });

    it('should return patterns for path-based routing', () => {
      const patterns = routeGenerator.getRoutePatterns(
        'example.com',
        'production',
        { zoneId: 'abc123', apiBasePath: '/data-service' }
      );

      expect(patterns).toContain('example.com/data-service/*');
    });

    it('should handle apiBasePath correctly', () => {
      const patterns = routeGenerator.getRoutePatterns(
        'api.example.com',
        'production',
        { zoneId: 'abc123', apiBasePath: '/v1' }
      );

      expect(patterns).toContain('api.example.com/*');
      expect(patterns).toContain('example.com/v1/*');
    });

    it('should prioritize patterns by specificity', () => {
      const patterns = routeGenerator.getRoutePatterns(
        'api.example.com',
        'production',
        { zoneId: 'abc123' }
      );

      // Subdomain pattern should come before root domain fallback
      const subdomainIndex = patterns.indexOf('api.example.com/*');
      const rootIndex = patterns.indexOf('example.com/api/*');

      expect(subdomainIndex).toBeLessThan(rootIndex);
    });
  });
});
