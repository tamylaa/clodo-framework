#!/usr/bin/env node

/**
 * Secret Generation Utility
 * Generates cryptographically secure secrets for production deployment
 * Now with secret persistence for cross-service sharing
 */

import { randomBytes } from 'crypto';
import { writeFileSync, readFileSync, mkdirSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = join(__dirname, '..', '..');
const SECRETS_DIR = join(PROJECT_ROOT, 'secrets');

function generateSecret(length = 32) {
  return randomBytes(length).toString('hex');
}

function generateSecrets(options = {}) {
  const { domainName, reuseSecrets = false, saveToFile = false, environment = 'production' } = options;
  
  console.log('üîê PRODUCTION SECRETS GENERATOR');
  console.log('================================');
  console.log('');
  console.log('‚ö†Ô∏è  IMPORTANT: Store these secrets securely and never commit them to git!');
  console.log('');
  
  let secrets = {};
  let secretsFile = null;
  
  // Set up file paths if domain name provided
  if (domainName) {
    if (!existsSync(SECRETS_DIR)) {
      mkdirSync(SECRETS_DIR, { recursive: true });
    }
    secretsFile = join(SECRETS_DIR, `${domainName}-secrets.json`);
  }
  
  // Always try to reuse existing secrets for consistency across services
  if (secretsFile && existsSync(secretsFile)) {
    try {
      const existing = JSON.parse(readFileSync(secretsFile, 'utf8'));
      const { domain: _domain, environment: _env, generated: _gen, note: _note, ...existingSecrets } = existing;
      secrets = existingSecrets;
      console.log(`üìÇ Reusing existing secrets for domain '${domainName}' (consistent across services)`);
      console.log(`üïí Originally generated: ${existing.generated}`);
      console.log('');
      console.log('üîÑ IMPORTANT: Using existing secrets ensures all services can authenticate with each other');
    } catch (error) {
      console.log('‚ö†Ô∏è  Could not load existing secrets, generating new ones...');
    }
  } else if (domainName) {
    console.log(`üÜï Creating new secrets for domain '${domainName}'`);
  }
  
  // Generate any missing secrets
  if (!secrets.AUTH_JWT_SECRET) secrets.AUTH_JWT_SECRET = generateSecret(32);
  if (!secrets.X_SERVICE_KEY) secrets.X_SERVICE_KEY = generateSecret(32);
  if (!secrets.AUTH_SERVICE_API_KEY) secrets.AUTH_SERVICE_API_KEY = generateSecret(24);
  if (!secrets.LOGGER_SERVICE_API_KEY) secrets.LOGGER_SERVICE_API_KEY = generateSecret(24);
  if (!secrets.CONTENT_SKIMMER_API_KEY) secrets.CONTENT_SKIMMER_API_KEY = generateSecret(24);
  
  // Save secrets to file if requested
  if ((saveToFile || domainName) && secretsFile) {
    try {
      const secretsData = {
        ...secrets,
        domain: domainName,
        environment,
        generated: new Date().toISOString(),
        note: 'Generated by generate-secrets.js - Share with other services for authentication'
      };
      writeFileSync(secretsFile, JSON.stringify(secretsData, null, 2));
      console.log(`üíæ Secrets saved to: ${secretsFile}`);
      console.log('üìã Other services can load these secrets for consistent authentication');
    } catch (error) {
      console.log(`‚ö†Ô∏è  Could not save secrets to file: ${error.message}`);
    }
  }
  
  console.log('');
  console.log('Generated secrets:');
  console.log('');
  
  for (const [key, value] of Object.entries(secrets)) {
    console.log(`${key}=${value}`);
  }
  
  console.log('');
  console.log('üöÄ To set these in Cloudflare Workers:');
  console.log('');
  
  for (const [key, value] of Object.entries(secrets)) {
    console.log(`echo "${value}" | wrangler secret put ${key} --env ${environment}`);
  }
  
  console.log('');
  console.log(`For other environments, replace --env ${environment} with --env staging or --env development`);
  console.log('');
  console.log('üí° You can also set these individually when prompted by the deployment script.');
  
  return secrets;
}

// Command line interface
function parseArgs() {
  const args = process.argv.slice(2);
  const options = {};
  
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--domain':
        options.domainName = args[++i];
        options.saveToFile = true;
        break;
      case '--reuse':
        options.reuseSecrets = true;
        break;
      case '--environment':
      case '--env':
        options.environment = args[++i];
        break;
      case '--save':
        options.saveToFile = true;
        break;
      case '--help':
        console.log(`
Usage: node generate-secrets.js [options]

Options:
  --domain <name>      Domain name (enables file saving)
  --reuse             Try to reuse existing secrets
  --env <environment>  Environment (production, staging, development)
  --save              Force save to file
  --help              Show this help

Examples:
  node generate-secrets.js                                    # Generate one-time secrets
  node generate-secrets.js --domain newclient --env production # Create domain secrets (reusable)
  node generate-secrets.js --domain newclient                 # Reuse existing domain secrets
        `);
        process.exit(0);
        break;
    }
  }
  
  return options;
}

// Run if called directly
if (process.argv[1] && import.meta.url.endsWith(process.argv[1].replace(/\\/g, '/'))) {
  const options = parseArgs();
  generateSecrets(options);
}

export { generateSecret, generateSecrets };