# Middleware Architecture Migration Summary (v4.1)

## üìå Purpose
This document captures the design decisions, implementation details, assumptions, tests, migration steps, and next actions for the contract-first middleware migration (v4.1): moving from per-service concrete middleware implementations (`createServiceMiddleware`) to lightweight middleware contracts with a shared runtime (Registry + Composer).

---

## üîß What was implemented
- Default approach: **contract-first** middleware generation with opt-in `legacy` strategy.
- New runtime primitives (framework-level):
  - `src/middleware/Registry.js` - central registry API used in tests and tooling.
  - `src/middleware/Composer.js` - middleware composer that executes middleware chains with short-circuiting and post-processing.
  - `src/middleware/types.d.ts` - TypeScript types describing `IServiceMiddleware` and `IMiddlewareChain`.
  - `src/middleware/shared/` - framework shared middleware: `cors`, `logging`, `basicAuth` (exports in `index.js`).
- Generator changes:
  - `ServiceMiddlewareGenerator` now emits either:
    - A minimal contract class + `registerMiddleware` helper (contract strategy), or
    - A legacy `createServiceMiddleware` factory (legacy strategy).
  - Generator also emits a self-contained `src/middleware/runtime.js` and a `src/middleware/shared/` folder when generating services (for self-containment).
- Worker entry updates:
  - `WorkerIndexGenerator` updated to import middleware runtime and compose pipeline using `MiddlewareComposer` + `MiddlewareRegistry`.
  - Worker fetch runtime supports both contract registration and legacy factory via an adapter.
- Migration tools & tests:
  - `scripts/migration/migrate-middleware-legacy-to-contract.js` (basic codemod to convert legacy factories to contract skeletons + `registerMiddleware`).
  - Unit tests added for `Registry`, `Composer`, `shared/cors`, generator outputs, and migration script.
- CLI:
  - `cli/commands/create.js` adds `--middleware-strategy <strategy>` CLI flag (default `contract`).
- Docs & changelog updated:
  - `docs/HOWTO_CONSUME_CLODO_FRAMEWORK.md` updated to describe the new approach.
  - `CHANGELOG.md` mentions the v4.1 middleware architecture change.

---

## ‚úÖ Files added / modified (high-level)
- Added:
  - `src/middleware/Registry.js`
  - `src/middleware/Composer.js`
  - `src/middleware/types.d.ts`
  - `src/middleware/shared/{cors.js,logging.js,basicAuth.js,index.js}`
  - `scripts/migration/migrate-middleware-legacy-to-contract.js`
  - `docs/MIDDLEWARE_MIGRATION_SUMMARY.md` (this file)
  - Tests: `test/utils/middleware/{Registry,Composer,cors}.test.js`, generator tests and migration test
- Modified (generators & templates):
  - `src/service-management/generators/code/ServiceMiddlewareGenerator.js` (now emits contract or legacy output and service-local runtime/shared stubs)
  - `src/service-management/generators/code/WorkerIndexGenerator.js` (loads middleware using dynamic import and composes pipeline; includes legacy adapter)
  - `src/service-management/GenerationEngine.js` (passes `middlewareStrategy` through context)
  - `src/service-management/ServiceOrchestrator.js` & `src/simple-api.js` (accept middleware strategy)
  - `cli/commands/create.js` (new `--middleware-strategy` option)

---

## üß≠ Key assumptions made
1. Default strategy is `contract` (opt-in `legacy`).
2. Generated services are self-contained by default (runtime + shared stubs added into generated service) to work standalone.
3. Legacy factory shape expected to return object with `processRequest(request)` and `processResponse(response)` methods.
4. Runtime dynamic import is acceptable in Worker code (`await import('../middleware/service-middleware.js')`).
5. TypeScript users will later add TS skeletons or `.d.ts` files if they require compile-time checks.

If any of these assumptions are not desirable for your environment, they require small changes (see "Nuances and review points").

---

## ‚ö†Ô∏è Nuances & review points (actionable)
- Registry duplication:
  - There are both framework-level `Registry.js` and a service-local `runtime.js` (generated by the generator). Decide whether you want a single shared runtime or per-service runtime. If you prefer a single runtime, update the generator to import the framework runtime rather than generate a local copy.
- Bundler behavior & dynamic imports:
  - The dynamic import pattern must be tested with your bundler (esbuild/wrangler). Ensure bundler includes generated middleware files in the built artifact.
- Adapter coverage:
  - The legacy adapter covers the common `createServiceMiddleware` factory shape. If your legacy services used other shapes, extend the adapter logic accordingly.
- TypeScript support:
  - Generated skeletons are JavaScript; if you primarily use TypeScript, consider adding `.ts` templates and `.d.ts` exports for better DX.
- Migration tool limitations:
  - The codemod is intentionally conservative and may require manual editing for complex legacy middleware logic.
- Security/logging:
  - The example `logging` middleware uses `console.log` directly‚Äîavoid logging sensitive headers. Consider adding redaction configuration.

---

## üîÅ Migration steps (recommended)
1. Try generating a new service with default (contract) strategy to validate the new flow:
   - `npx clodo-service create --middleware-strategy contract` (or omit flag ‚Äî default is `contract`).
2. To generate an old-style output for a single new service for comparison: `npx clodo-service create --middleware-strategy legacy`.
3. For existing services using legacy middleware:
   - Run `node scripts/migration/migrate-middleware-legacy-to-contract.js <servicePath> [serviceName]`.
   - Review the converted skeleton and verify imports and custom logic‚Äîmake adjustments as required.
4. Update tests and CI to include a smoke test that deploys/loads the generated service (both contract and legacy flows).

---

## ‚úÖ Tests & QA to add (if not already present)
- Integration tests that:
  - Generate a service with `contract` strategy and verify `registerMiddleware` is invoked and runtime pipeline executes correctly.
  - Generate a service with `legacy` strategy and verify the legacy adapter path executes `createServiceMiddleware`.
- Bundle-size smoke test that measures the generated artifact size between legacy and contract strategies.
- Migration tests on representative real-world legacy middleware shapes.

---

## üìã Next steps & open todos
- Complete migration of tests and e2e fixtures that currently rely on legacy middleware.
- Add TypeScript skeleton templates (optional, recommended for TS-first projects).
- Decide on runtime model: service-local runtime (current) vs centralized runtime (change generator behavior if you prefer central runtime).
- Add more robust adapter patterns if you encounter edge-case legacy middleware shapes in the wild.

---

## üìé Helpful quick references
- Generator: `src/service-management/generators/code/ServiceMiddlewareGenerator.js`
- Worker: `src/service-management/generators/code/WorkerIndexGenerator.js`
- Migration: `scripts/migration/migrate-middleware-legacy-to-contract.js`
- Runtime: `src/middleware/{Registry.js,Composer.js}`
- Tests: `test/utils/middleware/*`, `test/service-management/generators/*`, `test/scripts/migration/*`

---

If you'd like, I can now:
- Finish updating tests/fixtures and add the bundle-size smoke test, or
- Add TypeScript templates for generated services, or
- Replace per-service runtime with a centralized runtime (if you prefer that model).

Pick one of the bullets above and I‚Äôll proceed. If you'd like further edits to this summary, I can fold them into this document.
