# Domain-Specific Configuration Management Architecture

## Current State Analysis (v2.0.19)

### Overview
The Clodo Framework currently manages domain-specific configuration through a **multi-layered system** involving three primary configuration files:

1. **`wrangler.toml`** - Cloudflare Workers deployment configuration
2. **`config/customers/<customer>/<env>.env`** - Customer deployment records  
3. **`src/config/domains.js`** - Service worker domain configuration (in generated services)

---

## Configuration Layers & Responsibilities

### 1. `wrangler.toml` - Cloudflare Deployment Configuration

**Managed By**: `WranglerConfigManager` (384 lines)  
**Location**: Project root  
**Format**: TOML  
**Parser**: `@iarna/toml`

**Purpose**:
- Cloudflare Workers deployment settings
- D1 database bindings per environment
- KV namespace bindings
- R2 bucket bindings
- Worker routes and compatibility settings
- Environment-specific overrides

**Structure**:
```toml
name = "my-service"
main = "src/worker/index.js"
compatibility_date = "2024-01-01"

# Production environment (top-level)
[[d1_databases]]
binding = "DB"
database_name = "example-com-production-db"
database_id = "abc123"

# Staging environment
[env.staging]
name = "my-service-staging"

[[env.staging.d1_databases]]
binding = "DB"
database_name = "example-com-staging-db"
database_id = "def456"
```

**Key Operations** (via WranglerConfigManager):
- `ensureEnvironment(env)` - Create/verify [env.X] section
- `addDatabaseBinding(env, dbInfo)` - Add D1 database to environment
- `getDatabaseBindings(env)` - Retrieve database configurations
- `readConfig()` / `writeConfig()` - TOML parsing and persistence

**Critical Implementation Details**:
- Production uses **top-level** configuration (no `[env.production]`)
- Staging/Development use **`[env.X]`** sections
- Database bindings are arrays: `[[d1_databases]]` or `[[env.X.d1_databases]]`

**Used During**:
- Database setup (`MultiDomainOrchestrator.setupDomainDatabase()`)
- Worker deployment (`MultiDomainOrchestrator.deployDomainWorker()`)
- Wrangler CLI commands execution

---

### 2. Customer .env Files - Deployment Records

**Managed By**: `UnifiedConfigManager` (540 lines)  
**Location**: `config/customers/<customer>/<environment>.env`  
**Format**: `.env` (KEY=VALUE)

**Purpose**:
- Store deployment results and metadata
- Track customer identity and Cloudflare credentials
- Record database IDs, worker URLs, and deployment artifacts
- Provide audit trail for each deployment

**Structure**:
```env
# Deployment Configuration - example-customer (production)
# Last Updated: 2025-10-12T15:30:00.000Z
# Auto-generated by Clodo Framework deployment

# ============================================
# Core Customer Identity
# ============================================
CUSTOMER_ID=example-customer
CUSTOMER_NAME=example-customer
ENVIRONMENT=production

# ============================================
# Cloudflare Configuration
# ============================================
CLOUDFLARE_ACCOUNT_ID=abcd1234567890abcd1234567890abcd
CLOUDFLARE_ZONE_ID=efgh5678901234efgh5678901234efgh
CLOUDFLARE_API_TOKEN=***redacted***

# ============================================
# Service Configuration
# ============================================
SERVICE_NAME=example-service
SERVICE_TYPE=generic
DISPLAY_NAME=Example Customer Service
DESCRIPTION=Production service for example-customer

# ============================================
# Domain Configuration
# ============================================
DOMAIN=example.com
CUSTOMER_DOMAIN=example.com
DEPLOYMENT_URL=https://api.example.com
API_DOMAIN=https://api.example.com

# ============================================
# Database Configuration
# ============================================
DATABASE_NAME=example-com-production-db
D1_DATABASE_NAME=example-com-production-db
D1_DATABASE_ID=abc123def456

# ============================================
# Worker Configuration
# ============================================
WORKER_NAME=example-service-production
WORKER_URL=https://api.example.com
```

**Key Operations** (via UnifiedConfigManager):
- `loadCustomerConfig(customer, env)` - Load existing deployment record
- `saveCustomerConfig(customer, env, data)` - Save deployment results
- `listCustomers()` - Get all configured customers
- `displayCustomerConfig(customer, env)` - Show config summary
- `parseToStandardFormat(envVars)` - Convert to InputCollector format
- `isTemplateConfig(envVars)` - Detect placeholder configs

**Critical Features**:
- **Single .env parser** - eliminated duplication from 2 previous implementations
- **Template detection** - skips configs with `{{}}` placeholders or invalid IDs
- **Safe loading** - `loadCustomerConfigSafe()` never throws, returns defaults
- **Comprehensive sections** - organized by concern (identity, cloudflare, service, domain, database, worker)

**Used During**:
- Pre-deployment: Load existing configs for re-deployment
- Post-deployment: Save deployment results for record-keeping
- Input collection: Pre-fill prompts with stored values
- Configuration display: Show current deployment state

---

### 3. `src/config/domains.js` - Worker Domain Configuration

**Managed By**: Service worker itself (generated from template)  
**Location**: `<service-project>/src/config/domains.js`  
**Format**: JavaScript ES Module

**Purpose**:
- Runtime configuration for deployed workers
- Environment-specific URLs and settings
- Feature flags and service capabilities
- Database and KV namespace references

**Structure**:
```javascript
import { createDomainConfigSchema } from '@tamyla/clodo-framework';

export const domains = {
  'example-service': {
    ...createDomainConfigSchema(), // Framework schema
    name: 'example-service',
    displayName: 'Example Service',
    accountId: process.env.CLOUDFLARE_ACCOUNT_ID || '',
    zoneId: process.env.CLOUDFLARE_ZONE_ID || '',
    domains: {
      production: process.env.PRODUCTION_DOMAIN || 'api.example.com',
      staging: process.env.STAGING_DOMAIN || 'staging-api.example.com',
      development: process.env.DEVELOPMENT_DOMAIN || 'dev-api.example.com'
    },
    services: ['example-service'],
    databases: [
      { name: 'example-service-db', type: 'd1' }
    ],
    features: {
      logging: true,
      monitoring: true,
      errorReporting: true,
      authentication: false,
      caching: false
    },
    settings: {
      environment: process.env.ENVIRONMENT || 'development',
      logLevel: process.env.LOG_LEVEL || 'info',
      corsOrigins: process.env.CORS_ORIGINS ? process.env.CORS_ORIGINS.split(',') : ['*'],
      rateLimitRequests: parseInt(process.env.RATE_LIMIT_REQUESTS) || 100,
      rateLimitWindowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 60000
    }
  }
};

export function getDomainConfig(domainName = 'example-service') {
  const config = domains[domainName];
  if (!config) {
    throw new Error(`Domain configuration not found: ${domainName}`);
  }
  return config;
}
```

**Key Characteristics**:
- **Runtime configuration** - loaded by worker at request time
- **Environment variables** - pulls from `process.env` (set via wrangler.toml)
- **Framework integration** - uses `createDomainConfigSchema()` for consistency
- **Feature flags** - enables/disables capabilities per service type
- **Multi-environment** - different URLs for production/staging/development

**Used During**:
- Worker initialization (`initializeService(env, domainConfigs)`)
- Request handling (domain routing, feature checks)
- Service orchestration (multi-service coordination)

**Generated By**:
- `templates/generic/src/config/domains.js` template
- Populated during service scaffolding (`bin/clodo-service.js`)

---

## Configuration Flow During Deployment

### Phase 1: Input Collection
```
MultiDomainOrchestrator.initialize()
  ↓
UnifiedConfigManager.loadCustomerConfig(customer, env)
  ↓ (if found)
Pre-populate prompts with stored values
  ↓ (if not found)
Collect new inputs via InputCollector
```

### Phase 2: Database Setup
```
MultiDomainOrchestrator.setupDomainDatabase(domain)
  ↓
DatabaseOrchestrator.createDatabase(name)
  ↓
WranglerConfigManager.ensureEnvironment(env)
  ↓
WranglerConfigManager.addDatabaseBinding(env, dbInfo)
  ↓
Write wrangler.toml (TOML format)
```

### Phase 3: Worker Deployment
```
MultiDomainOrchestrator.deployDomainWorker(domain)
  ↓
WranglerConfigManager.ensureEnvironment(env)
  ↓
Execute: npx wrangler deploy --env <env>
  ↓ (wrangler reads wrangler.toml)
Worker deployed to Cloudflare
```

### Phase 4: Results Persistence
```
MultiDomainOrchestrator.deploy() [completion]
  ↓
UnifiedConfigManager.saveCustomerConfig(customer, env, data)
  ↓
Write config/customers/<customer>/<env>.env
  ↓
Deployment record saved for future reference
```

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                    DOMAIN CONFIGURATION LAYERS                      │
└─────────────────────────────────────────────────────────────────────┘

┌────────────────────┐
│ Customer .env Files│ ← UnifiedConfigManager
│ (Deployment Records)│
│ - Customer identity│
│ - Cloudflare creds │
│ - Deployment results│
└──────┬─────────────┘
       │
       │ Pre-deployment: Load existing configs
       │ Post-deployment: Save results
       │
       ↓
┌────────────────────┐
│ MultiDomainOrchest│
│       rator        │ ← Coordinates deployment
└──────┬─────────────┘
       │
       │ Setup database, configure wrangler.toml
       │
       ↓
┌────────────────────┐
│  wrangler.toml     │ ← WranglerConfigManager
│ (Cloudflare Config)│
│ - Worker settings  │
│ - Database bindings│
│ - Environment overr│
└──────┬─────────────┘
       │
       │ Deployment: wrangler deploy --env <env>
       │
       ↓
┌────────────────────┐
│ Cloudflare Workers │
│  (Deployed Worker) │
└──────┬─────────────┘
       │
       │ Runtime: Load domain config
       │
       ↓
┌────────────────────┐
│ src/config/        │
│   domains.js       │
│ (Worker Config)    │
│ - Runtime settings │
│ - Feature flags    │
│ - Environment URLs │
└────────────────────┘
```

---

## Key Components

### WranglerConfigManager
**File**: `src/utils/deployment/wrangler-config-manager.js` (384 lines)  
**Tests**: 15/15 Jest + 14/14 Integration (100% passing)

**Responsibilities**:
- Parse/write `wrangler.toml` using `@iarna/toml`
- Manage environment sections (`[env.X]`)
- Add/remove database bindings
- Handle production vs staging configuration differences

**API**:
```javascript
const manager = new WranglerConfigManager({ projectRoot: '/path/to/project' });

// Create environment section if needed
await manager.ensureEnvironment('staging');

// Add database to environment
await manager.addDatabaseBinding('staging', {
  binding: 'DB',
  database_name: 'example-com-staging-db',
  database_id: 'abc123'
});

// Get all databases for environment
const dbs = await manager.getDatabaseBindings('production'); // returns top-level
```

### UnifiedConfigManager
**File**: `src/utils/config/unified-config-manager.js` (540 lines)  
**Tests**: 35/35 Integration (100% passing)

**Responsibilities**:
- Load customer `.env` files with template detection
- Save deployment results to `.env` format
- Parse `.env` to InputCollector-compatible format
- List customers and display configurations

**API**:
```javascript
const manager = new UnifiedConfigManager({ configDir: '/path/to/config/customers' });

// Load existing config
const config = manager.loadCustomerConfig('example-customer', 'production');

// Save deployment results
await manager.saveCustomerConfig('example-customer', 'production', {
  customer: 'example-customer',
  environment: 'production',
  coreInputs: { domainName: 'example.com', cloudflareAccountId: '...' },
  confirmations: { workerName: 'example-worker' },
  result: { databaseId: 'abc123', workerUrl: 'https://api.example.com' }
});

// List all customers
const customers = manager.listCustomers(); // ['example-customer', 'another-customer']
```

### MultiDomainOrchestrator
**File**: `src/orchestration/multi-domain-orchestrator.js` (617 lines)

**Responsibilities**:
- Coordinate multi-domain deployments
- Initialize configuration managers
- Setup databases (uses DatabaseOrchestrator + WranglerConfigManager)
- Deploy workers (uses WranglerConfigManager + wrangler CLI)
- Track deployment state (uses StateManager)

**Flow**:
```javascript
const orchestrator = new MultiDomainOrchestrator({
  domains: ['example.com', 'another.com'],
  environment: 'production',
  servicePath: '/path/to/service'
});

await orchestrator.initialize();
await orchestrator.deploy(); // Full deployment workflow
```

---

## Configuration File Comparison

| Aspect | `wrangler.toml` | Customer `.env` | `domains.js` |
|--------|----------------|----------------|--------------|
| **Format** | TOML | ENV | JavaScript |
| **Scope** | Deployment config | Deployment records | Runtime config |
| **Managed By** | WranglerConfigManager | UnifiedConfigManager | Developer/Template |
| **Updated When** | During deployment | Post-deployment | Service creation |
| **Used By** | Wrangler CLI | Clodo Framework | Worker runtime |
| **Contains** | Bindings, routes, settings | Customer identity, results | Feature flags, URLs |
| **Environment Handling** | [env.X] sections | Separate files per env | process.env variables |
| **Production Specifics** | Top-level config | production.env | domains.production |

---

## Critical Design Decisions

### 1. Why Three Configuration Files?

**Separation of Concerns**:
- **wrangler.toml**: What Cloudflare needs to deploy the worker
- **Customer .env**: What we need to track deployments and customer data
- **domains.js**: What the worker needs to run correctly

**Rationale**:
- Cloudflare Workers require `wrangler.toml` (not negotiable)
- Customer records need persistent storage separate from deployment config
- Worker needs runtime configuration independent of deployment artifacts

### 2. Production vs Environment Handling

**Why production is top-level in wrangler.toml**:
- Wrangler convention: default environment = production
- Reduces configuration noise for most common deployment
- Explicit `[env.staging]` makes non-production deployments clear

**Implementation**:
```javascript
// WranglerConfigManager.getDatabaseBindings()
if (env === 'production') {
  return config.d1_databases || []; // Top-level
} else {
  return config.env?.[env]?.d1_databases || []; // env.X
}
```

### 3. TOML vs ENV vs JS

**TOML for wrangler.toml**:
- Cloudflare's required format
- Good for hierarchical config
- Parser: `@iarna/toml` (robust, well-tested)

**ENV for customer configs**:
- Simple KEY=VALUE pairs
- Easy to parse, edit, version control
- Industry standard for secrets and deployment config
- Compatible with dotenv tools

**JavaScript for domains.js**:
- Type-safe, IDE-friendly
- Can use expressions and logic
- Integrates with framework exports
- Supports environment variable fallbacks

---

## Usage Examples

### Example 1: Deploy New Customer

```javascript
// 1. Orchestrator loads/creates customer config
const config = unifiedConfigManager.loadCustomerConfig('acme-corp', 'production');
// Returns null if not found, loads existing if found

// 2. Collect inputs (pre-filled if config exists)
const inputs = await inputCollector.collectInputs(config);

// 3. Setup database + update wrangler.toml
await orchestrator.setupDomainDatabase('acme.com');
// Creates D1 database
// Adds to wrangler.toml: [[d1_databases]]

// 4. Deploy worker
await orchestrator.deployDomainWorker('acme.com');
// Runs: npx wrangler deploy
// Wrangler reads wrangler.toml

// 5. Save results
await unifiedConfigManager.saveCustomerConfig('acme-corp', 'production', {
  coreInputs: inputs,
  result: { databaseId: 'abc123', workerUrl: 'https://api.acme.com' }
});
// Writes to: config/customers/acme-corp/production.env
```

### Example 2: Update Database Binding

```javascript
const manager = new WranglerConfigManager({ projectRoot: '.' });

// Add new database to staging
await manager.addDatabaseBinding('staging', {
  binding: 'ANALYTICS_DB',
  database_name: 'acme-com-staging-analytics',
  database_id: 'def456'
});

// wrangler.toml now has:
// [[env.staging.d1_databases]]
// binding = "ANALYTICS_DB"
// database_name = "acme-com-staging-analytics"
// database_id = "def456"
```

### Example 3: Access Domain Config in Worker

```javascript
// Worker: src/worker/index.js
import { domains } from './config/domains.js';

export default {
  async fetch(request, env, ctx) {
    const config = domains['my-service'];
    
    // Check feature flag
    if (config.features.authentication) {
      // Run authentication middleware
    }
    
    // Get environment-specific URL
    const apiUrl = config.domains[config.settings.environment];
    
    // Use database binding (set via wrangler.toml)
    const db = env.DB; // Matches [[d1_databases]] binding = "DB"
    const results = await db.prepare('SELECT * FROM users').all();
    
    return new Response(JSON.stringify(results));
  }
};
```

---

## Common Pitfalls & Solutions

### Pitfall 1: Production Database in Wrong Section

**Problem**: Adding production database to `[env.production]` instead of top-level

**Wrong**:
```toml
[env.production]
[[env.production.d1_databases]]
binding = "DB"
database_name = "my-db"
```

**Correct**:
```toml
# Top-level = production
[[d1_databases]]
binding = "DB"
database_name = "my-db"
```

**Solution**: `WranglerConfigManager.addDatabaseBinding()` handles this automatically

### Pitfall 2: Template Configs in Production

**Problem**: Deploying with template placeholders like `{{SERVICE_NAME}}`

**Detection**:
```javascript
// UnifiedConfigManager.isTemplateConfig()
if (envVars.CUSTOMER_NAME?.includes('{{') ||
    envVars.CLOUDFLARE_ACCOUNT_ID === '00000000000000000000000000000000') {
  return true; // Skip this config
}
```

**Solution**: `loadCustomerConfig()` returns `null` for templates, preventing deployment

### Pitfall 3: Mixing Configuration Sources

**Problem**: Updating `wrangler.toml` manually, then framework overwrites it

**Best Practice**:
- Always use `WranglerConfigManager` for programmatic updates
- Manual edits to `wrangler.toml` are preserved unless specific section is updated
- Customer `.env` files are append-only (never delete, only add sections)

---

## Future Enhancements

### Potential Improvements

1. **Unified Configuration Format**
   - Single source of truth (JSON/YAML/TOML)
   - Generate `wrangler.toml`, `.env`, and `domains.js` from master config
   - Reduce duplication across files

2. **Configuration Validation**
   - JSON Schema for customer configs
   - TOML validation before wrangler deploy
   - Required field checks (accountId, zoneId, etc.)

3. **Environment Variable Injection**
   - Automatic sync from `.env` to `wrangler.toml` vars section
   - Encrypted secrets in customer configs
   - Environment-specific variable overrides

4. **Configuration Diffing**
   - Compare current vs. stored configs
   - Detect configuration drift
   - Rollback to previous configurations

5. **Multi-Tenant Configuration**
   - Support multiple customers per domain
   - Tenant-specific feature flags
   - Dynamic configuration loading

---

## Conclusion

The current domain configuration architecture uses **three complementary files**:

1. **`wrangler.toml`** - Cloudflare deployment requirements (managed by WranglerConfigManager)
2. **Customer `.env`** - Deployment records and audit trail (managed by UnifiedConfigManager)
3. **`domains.js`** - Worker runtime configuration (developer-managed, template-generated)

This separation provides:
- ✅ Clear separation of concerns
- ✅ Cloudflare compatibility (wrangler.toml)
- ✅ Deployment tracking (customer .env)
- ✅ Runtime flexibility (domains.js)
- ✅ Environment isolation (production vs staging vs development)
- ✅ Type safety and IDE support (JavaScript config)

The architecture is **not just about wrangler.toml** - it's a comprehensive system for managing customer deployments across the entire lifecycle from input collection to worker runtime.

**Status**: Fully implemented and tested (100% test coverage) as of v2.0.19
