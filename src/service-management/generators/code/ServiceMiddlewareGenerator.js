import { BaseGenerator } from '../BaseGenerator.js';
import { join } from 'path';
import { mkdirSync, writeFileSync } from 'fs';

/**
 * Service Middleware Generator
 * Generates middleware functions for request/response processing
 */
export class ServiceMiddlewareGenerator extends BaseGenerator {
  /**
   * Generate service middleware
   * @param {Object} context - Generation context
   * @returns {Promise<string>} Path to generated middleware file
   */
  async generate(context) {
    const { coreInputs, confirmedValues, servicePath } = this.extractContext(context);
    
    if (!this.shouldGenerate(context)) {
      return null;
    }

    // Allow legacy strategy if requested by context
    const strategy = context && context.middlewareStrategy ? context.middlewareStrategy : 'contract';

    let middlewareContent;
    if (strategy === 'legacy') {
      middlewareContent = `/**
 * ${confirmedValues.displayName} - Service Middleware (LEGACY)
 *
 * Generated by Clodo Framework GenerationEngine
 * Service Type: ${coreInputs.serviceType}
 */

export function createServiceMiddleware(serviceConfig, env) {
  return {
    async processRequest(request) {
      let processedRequest = request;

      // Add service context headers
      const headers = new Headers(request.headers);
      headers.set('X-Service', serviceConfig.name);
      headers.set('X-Version', '${confirmedValues.version}');
      headers.set('X-Environment', '${coreInputs.environment}');
      headers.set('X-Request-ID', crypto.randomUUID());

      // CORS headers for API requests
      if (request.url.includes('${confirmedValues.apiBasePath}')) {
        headers.set('Access-Control-Allow-Origin', '*');
        headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
        headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
      }

      ${confirmedValues.features && confirmedValues.features.logging ? `
      // Request logging
      console.log('[' + new Date().toISOString() + '] ' + request.method + ' ' + request.url);` : ''}

      ${confirmedValues.features && confirmedValues.features.rateLimiting ? `
      // Rate limiting (placeholder - implement based on requirements)
      // This would typically check request frequency and block if over limit` : ''}

      ${confirmedValues.features && confirmedValues.features.authentication ? `
      // Authentication middleware (placeholder)
      // This would validate JWT tokens, API keys, etc.` : ''}

      ${confirmedValues.features && confirmedValues.features.authorization ? `
      // Authorization middleware (placeholder)
      // This would check user permissions and roles` : ''}

      return new Request(request.url, {
        ...request,
        headers
      });
    },

    async processResponse(response) {
      const headers = new Headers(response.headers);

      // Add standard response headers
      headers.set('X-Service', serviceConfig.name);
      headers.set('X-Version', '${confirmedValues.version}');
      headers.set('X-Response-Time', Date.now().toString());

      ${confirmedValues.features && confirmedValues.features.monitoring ? `
      // Response monitoring
      console.log('Response: ' + response.status + ' (' + Date.now() + 'ms)');` : ''}

      ${confirmedValues.features && confirmedValues.features.caching ? `
      // Cache headers (placeholder - implement based on content type)
      if (response.status === 200) {
        headers.set('Cache-Control', 'public, max-age=300'); // 5 minutes
      }` : ''}

      return new Response(response.body, {
        ...response,
        headers
      });
    }
  };
}
`;
    } else {
      middlewareContent = `/**
 * ${confirmedValues.displayName} - Service Middleware
 *
 * Generated by Clodo Framework GenerationEngine
 * Service Type: ${coreInputs.serviceType}
 */

// Service middleware contract skeleton - minimal and opt-in
export default class ${confirmedValues.packageName || confirmedValues.serviceName ? confirmedValues.serviceName : 'Service'}Middleware {
  // Implement only the hooks you need
  async preprocess(request) { return null; }
  async authenticate(request) { return null; }
  async validate(request) { return null; }
  async postprocess(response) { return response; }
}

// Optional registration helper - Worker generator will call this to register
export function registerMiddleware(registry, serviceName) {
  if (!registry || typeof registry.register !== 'function') return;
  try {
    registry.register(serviceName || '${coreInputs.serviceName}', new (exports.default || ${confirmedValues.packageName || confirmedValues.serviceName ? confirmedValues.serviceName : 'Service'}Middleware)());
  } catch (e) {
    // Non-fatal - allow services to manually register if needed
  }
}

`;
    }

    const filePath = join(servicePath, 'src', 'middleware', 'service-middleware.js');
    
    // Ensure directory exists
    const dir = join(servicePath, 'src', 'middleware');
    mkdirSync(dir, { recursive: true });
    
    writeFileSync(filePath, middlewareContent, 'utf8');
    this.logger.info(`Generated: ${filePath}`);

    // Also generate a lightweight runtime helper for middleware composition and registry
    let runtimeContent = '';

    // If Durable Objects are enabled (support both singular/plural feature names), inject DO imports/bindings
    if (confirmedValues.features && (confirmedValues.features.durableObjects || confirmedValues.features.durableObject)) {
      runtimeContent += `// Durable Object imports and bindings\nimport { DurableObject } from '@cloudflare/workers-types';\nexport const DURABLE_OBJECT = { type: 'durable_object', className: 'MyDurableObject' };\n\n`;
    }

    runtimeContent += `// Lightweight middleware runtime for generated services
export const MiddlewareRegistry = (() => {
  const map = new Map();
  return {
    register(serviceName, instance) { map.set(serviceName, instance); },
    get(serviceName) { return map.get(serviceName) || null; },
    clear() { map.clear(); }
  };
})();

export const MiddlewareComposer = {
  compose(...middlewares) {
    const chain = middlewares.filter(Boolean);
    return {
      async execute(request, handler) {
        let req = request;
        for (const m of chain) {
          if (typeof m.preprocess === 'function') {
            const res = await m.preprocess(req);
            if (res) return res;
          }
          if (typeof m.authenticate === 'function') {
            const res = await m.authenticate(req);
            if (res) return res;
          }
          if (typeof m.validate === 'function') {
            const res = await m.validate(req);
            if (res) return res;
          }
        }
        let response = await handler(req);
        for (const m of chain.slice().reverse()) {
          if (typeof m.postprocess === 'function') {
            const updated = await m.postprocess(response);
            if (updated instanceof Response) response = updated;
          }
        }
        return response;
      }
    };
  }
};
`;
    const runtimePath = join(servicePath, 'src', 'middleware', 'runtime.js');
    writeFileSync(runtimePath, runtimeContent, 'utf8');
    this.logger.info(`Generated: ${runtimePath}`);

    // Minimal shared implementations (copied into generated service for self-containment)
    const sharedDir = join(servicePath, 'src', 'middleware', 'shared');
    mkdirSync(sharedDir, { recursive: true });

    const corsContent = `export function cors(options = {}) {
  const origin = options.origin || '*';
  const allowMethods = options.methods || 'GET, POST, PUT, DELETE, OPTIONS';
  const allowHeaders = options.headers || 'Content-Type, Authorization';

  return {
    preprocess(request) {
      if (request.method === 'OPTIONS') {
        const headers = new Headers();
        headers.set('Access-Control-Allow-Origin', origin);
        headers.set('Access-Control-Allow-Methods', allowMethods);
        headers.set('Access-Control-Allow-Headers', allowHeaders);
        return new Response(null, { status: 204, headers });
      }
      return null;
    },
    postprocess(response) {
      const headers = new Headers(response.headers);
      headers.set('Access-Control-Allow-Origin', origin);
      return new Response(response.body, { ...response, headers });
    }
  };
}
`;

    const loggingContent = `export function logging(options = {}) {
  const level = options.level || 'info';
  return {
    preprocess(request) {
      try {
        const path = new URL(request.url).pathname;
        console.log('[' + new Date().toISOString() + '] ' + level.toUpperCase() + ' ' + request.method + ' ' + path);
      } catch (e) {}
      return null;
    }
  };
}
`;

    const basicAuthContent = `export function basicAuth({ realm = 'Restricted' } = {}) {
  return {
    authenticate(request) {
      const auth = request.headers.get('Authorization');
      if (!auth) {
        return new Response(JSON.stringify({ error: 'Unauthorized' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json', 'WWW-Authenticate': 'Basic realm="' + realm + '"' }
        });
      }
      return null;
    }
  };
}
`;

    writeFileSync(join(sharedDir, 'cors.js'), corsContent, 'utf8');
    writeFileSync(join(sharedDir, 'logging.js'), loggingContent, 'utf8');
    writeFileSync(join(sharedDir, 'basicAuth.js'), basicAuthContent, 'utf8');

    const indexContent = `export { cors } from './cors.js';\nexport { logging } from './logging.js';\nexport { basicAuth } from './basicAuth.js';\n`;
    writeFileSync(join(sharedDir, 'index.js'), indexContent, 'utf8');

    this.logger.info(`Generated shared middleware in: ${sharedDir}`);

    return filePath;
  }

  /**
   * Determine if generator should run
   */
  shouldGenerate(context) {
    return true; // Always generate middleware
  }
}

