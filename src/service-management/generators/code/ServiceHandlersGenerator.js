import { BaseGenerator } from '../BaseGenerator.js';
import { join } from 'path';
import { mkdirSync, writeFileSync } from 'fs';

/**
 * Service Handlers Generator
 * Generates request handlers with routing, health checks, and API endpoints
 */
export class ServiceHandlersGenerator extends BaseGenerator {
  /**
   * Generate service handlers
   * @param {Object} context - Generation context
   * @returns {Promise<string>} Path to generated handlers file
   */
  async generate(context) {
    const { coreInputs, confirmedValues, servicePath } = this.extractContext(context);
    
    if (!this.shouldGenerate(context)) {
      return null;
    }

    const handlersContent = `/**
 * ${confirmedValues.displayName} - Service Handlers
 *
 * Generated by Clodo Framework GenerationEngine
 * Service Type: ${coreInputs.serviceType}
 */

import { healthCheckResponseSchema, errorResponseSchema } from '../schemas/service-schema.js';

export function createServiceHandlers(serviceConfig, env) {
  return {
    async handleRequest(request, ctx) {
      const url = new URL(request.url);
      const path = url.pathname;

      // Health check endpoint
      if (path === '${confirmedValues.healthCheckPath}') {
        return this.handleHealthCheck(request, serviceConfig);
      }

      // API routes
      if (path.startsWith('${confirmedValues.apiBasePath}')) {
        return this.handleApiRequest(request, ctx, serviceConfig, env);
      }

      // Default 404 response
      return new Response(JSON.stringify({
        error: 'Not Found',
        message: \`Endpoint not found: \${path}\`,
        availableEndpoints: [
          '${confirmedValues.healthCheckPath}',
          '${confirmedValues.apiBasePath}/*'
        ]
      }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    },

    async handleHealthCheck(request, serviceConfig) {
      try {
        // Perform health checks
        const healthStatus = await this.performHealthChecks(serviceConfig, env);

        const response = {
          status: healthStatus.overall === 'healthy' ? 'healthy' : 'unhealthy',
          timestamp: new Date().toISOString(),
          service: serviceConfig.name,
          version: '${confirmedValues.version}',
          environment: '${coreInputs.environment}',
          checks: healthStatus.checks
        };

        return new Response(JSON.stringify(response), {
          status: healthStatus.overall === 'healthy' ? 200 : 503,
          headers: { 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          status: 'unhealthy',
          timestamp: new Date().toISOString(),
          service: serviceConfig.name,
          error: error.message
        }), {
          status: 503,
          headers: { 'Content-Type': 'application/json' }
        });
      }
    },

    async handleApiRequest(request, ctx, serviceConfig, env) {
      try {
        const url = new URL(request.url);
        const path = url.pathname.replace('${confirmedValues.apiBasePath}', '');

        // Route to service-specific handlers
        switch (request.method) {
          case 'GET':
            return this.handleGet(path, request, ctx, serviceConfig, env);
          case 'POST':
            return this.handlePost(path, request, ctx, serviceConfig, env);
          case 'PUT':
            return this.handlePut(path, request, ctx, serviceConfig, env);
          case 'DELETE':
            return this.handleDelete(path, request, ctx, serviceConfig, env);
          default:
            return new Response(JSON.stringify({
              error: 'Method Not Allowed',
              message: \`Method \${request.method} not supported\`
            }), {
              status: 405,
              headers: { 'Content-Type': 'application/json' }
            });
        }
      } catch (error) {
        return new Response(JSON.stringify({
          error: 'Internal Server Error',
          message: error.message,
          timestamp: new Date().toISOString()
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
    },

    async performHealthChecks(serviceConfig, env) {
      const checks = [];

      // Database connectivity check
      try {
        ${confirmedValues.features.database ? `
        // Check database connection
        const dbCheck = await env.DB.prepare('SELECT 1 as health_check').first();
        checks.push({
          name: 'database',
          status: dbCheck ? 'healthy' : 'unhealthy',
          responseTime: Date.now()
        });` : `
        checks.push({
          name: 'database',
          status: 'disabled',
          message: 'Database not configured for this service type'
        });`}
      } catch (error) {
        checks.push({
          name: 'database',
          status: 'unhealthy',
          error: error.message
        });
      }

      // Service configuration check
      checks.push({
        name: 'configuration',
        status: serviceConfig ? 'healthy' : 'unhealthy',
        message: serviceConfig ? 'Service configuration loaded' : 'Service configuration missing'
      });

      // Overall health status
      const overall = checks.every(check => check.status === 'healthy' || check.status === 'disabled')
        ? 'healthy' : 'unhealthy';

      return { overall, checks };
    },

    // Placeholder handlers - implement based on service type
    async handleGet(path, request, ctx, serviceConfig, env) {
      return new Response(JSON.stringify({
        message: 'GET handler not implemented',
        path,
        service: serviceConfig.name,
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    },

    async handlePost(path, request, ctx, serviceConfig, env) {
      return new Response(JSON.stringify({
        message: 'POST handler not implemented',
        path,
        service: serviceConfig.name,
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    },

    async handlePut(path, request, ctx, serviceConfig, env) {
      return new Response(JSON.stringify({
        message: 'PUT handler not implemented',
        path,
        service: serviceConfig.name,
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    },

    async handleDelete(path, request, ctx, serviceConfig, env) {
      return new Response(JSON.stringify({
        message: 'DELETE handler not implemented',
        path,
        service: serviceConfig.name,
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }
  };
}
`;

    const filePath = join(servicePath, 'src', 'handlers', 'service-handlers.js');
    
    // Ensure directory exists
    const dir = join(servicePath, 'src', 'handlers');
    mkdirSync(dir, { recursive: true });
    
    writeFileSync(filePath, handlersContent, 'utf8');
    this.logger.info(`Generated: ${filePath}`);
    
    return filePath;
  }

  /**
   * Determine if generator should run
   */
  shouldGenerate(context) {
    return true; // Always generate handlers
  }
}
