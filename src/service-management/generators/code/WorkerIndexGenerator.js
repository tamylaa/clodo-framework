import { BaseGenerator } from '../BaseGenerator.js';
import { join } from 'path';

/**
 * WorkerIndexGenerator
 * 
 * Generates src/worker/index.js - the main Cloudflare Worker entry point.
 * 
 * Responsibilities:
 * - Generate Worker fetch handler
 * - Import domain configuration, handlers, and middleware
 * - Set up request/response processing pipeline
 * - Implement error handling with structured error responses
 * - Include service metadata in error headers
 * 
 * Output:
 * - src/worker/index.js (ES module with default export fetch handler)
 */
export class WorkerIndexGenerator extends BaseGenerator {
  constructor(options = {}) {
    super({
      name: 'WorkerIndexGenerator',
      description: 'Generates Cloudflare Worker entry point in src/worker/index.js',
      outputPath: 'src/worker/index.js',
      ...options
    });
  }

  /**
   * Always generate worker index
   */
  shouldGenerate(context) {
    return true;
  }

  /**
   * Generate src/worker/index.js
   */
  async generate(context) {
    // Support both new structured format and legacy flat format
    const coreInputs = context.coreInputs || context;
    const confirmedValues = context.confirmedValues || context;
    const servicePath = context.servicePath || context.outputDir;

    this.setContext({ coreInputs, confirmedValues, servicePath });

    // Build worker index content
    const content = this._buildWorkerIndex(coreInputs, confirmedValues);

    // Write file to src/worker/index.js
    await this.writeFile(join('src', 'worker', 'index.js'), content);

    // Return full path for backward compatibility
    return join(servicePath, 'src', 'worker', 'index.js');
  }

  /**
   * Build the complete worker index.js content
   */
  _buildWorkerIndex(coreInputs, confirmedValues) {
    return `/**
 * ${confirmedValues.displayName} - Cloudflare Worker
 *
 * Generated by Clodo Framework GenerationEngine
 * Service Type: ${coreInputs.serviceType}
 */

import { domains } from '../config/domains.js';
import { createServiceHandlers } from '../handlers/service-handlers.js';
import { MiddlewareRegistry, MiddlewareComposer } from '../middleware/runtime.js';
import * as Shared from '../middleware/shared/index.js';

export default {
  async fetch(request, env, ctx) {
    try {
      // Get service configuration
      const serviceConfig = domains['${coreInputs.serviceName}'];

      // Build shared middleware instances
      const sharedMiddlewares = [
        Shared.cors({ origin: serviceConfig.corsPolicy || '*' }),
        Shared.logging({ level: serviceConfig.logLevel || 'info' })
      ];

      // Lazy-load service middleware and support legacy factory compatibility
      let serviceMiddlewareInstance = null;
      let legacyFactory = null;

      try {
        const mod = await import('../middleware/service-middleware.js');

        if (mod?.registerMiddleware) {
          // New-style registration helper
          mod.registerMiddleware(MiddlewareRegistry, serviceConfig.name);
          serviceMiddlewareInstance = MiddlewareRegistry.get(serviceConfig.name);
        } else if (mod?.default) {
          const def = mod.default;
          // If the default is a class (constructor), instantiate and register
          if (typeof def === 'function' && def.prototype) {
            try {
              const instance = new def();
              MiddlewareRegistry.register(serviceConfig.name, instance);
              serviceMiddlewareInstance = instance;
            } catch (e) {
              // ignore instantiation errors
            }
          } else if (typeof def === 'function') {
            // Legacy factory exported as default
            legacyFactory = def;
          }
        } else if (mod?.createServiceMiddleware) {
          legacyFactory = mod.createServiceMiddleware;
        }
      } catch (e) {
        // No service-specific middleware found - continue with shared only
      }

      // Compose final middleware chain
      let chain;

      if (legacyFactory) {
        const legacyInstance = legacyFactory(serviceConfig, env);
        const adapter = {
          preprocess: async (req) => {
            if (legacyInstance && typeof legacyInstance.processRequest === 'function') {
              const processed = await legacyInstance.processRequest(req);
              if (processed instanceof Response) return processed; // short-circuit
              return null; // continue (legacy returns a Request)
            }
            return null;
          },
          postprocess: async (res) => {
            if (legacyInstance && typeof legacyInstance.processResponse === 'function') {
              const r = await legacyInstance.processResponse(res);
              return r instanceof Response ? r : res;
            }
            return res;
          }
        };

        chain = MiddlewareComposer.compose(...sharedMiddlewares, adapter);
      } else {
        const svcMw = serviceMiddlewareInstance || MiddlewareRegistry.get(serviceConfig.name);
        chain = MiddlewareComposer.compose(...sharedMiddlewares, svcMw);
      }

      // Execute middleware chain with final handler
      const response = await chain.execute(request, async (req) => {
        const handlers = createServiceHandlers(serviceConfig, env);
        return handlers.handleRequest(req, ctx);
      });

      return response;

    } catch (error) {
      console.error('Worker error:', error);

      return new Response(JSON.stringify({
        error: 'Internal Server Error',
        message: error.message,
        timestamp: new Date().toISOString()
      }), {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          'X-Service': '${coreInputs.serviceName}',
          'X-Version': '${confirmedValues.version}'
        }
      });
    }
  }
};
`;
  }

  /**
   * Validate context has required fields
   */
  validateContext(context) {
    const coreInputs = context.coreInputs || context;
    const confirmedValues = context.confirmedValues || context;

    const required = [
      { field: 'serviceName', source: coreInputs },
      { field: 'serviceType', source: coreInputs },
      { field: 'displayName', source: confirmedValues },
      { field: 'version', source: confirmedValues }
    ];

    const missing = required
      .filter(({ field, source }) => !source || !source[field])
      .map(({ field }) => field);

    if (missing.length > 0) {
      throw new Error(
        `WorkerIndexGenerator: Missing required fields: ${missing.join(', ')}`
      );
    }

    return true;
  }
}

