import { BaseGenerator } from '../BaseGenerator.js';
import { join } from 'path';

/**
 * WorkerIndexGenerator
 * 
 * Generates src/worker/index.js - the main Cloudflare Worker entry point.
 * 
 * Responsibilities:
 * - Generate Worker fetch handler
 * - Import domain configuration, handlers, and middleware
 * - Set up request/response processing pipeline
 * - Implement error handling with structured error responses
 * - Include service metadata in error headers
 * 
 * Output:
 * - src/worker/index.js (ES module with default export fetch handler)
 */
export class WorkerIndexGenerator extends BaseGenerator {
  constructor(options = {}) {
    super({
      name: 'WorkerIndexGenerator',
      description: 'Generates Cloudflare Worker entry point in src/worker/index.js',
      outputPath: 'src/worker/index.js',
      ...options
    });
  }

  /**
   * Always generate worker index
   */
  shouldGenerate(context) {
    return true;
  }

  /**
   * Generate src/worker/index.js
   */
  async generate(context) {
    // Support both new structured format and legacy flat format
    const coreInputs = context.coreInputs || context;
    const confirmedValues = context.confirmedValues || context;
    const servicePath = context.servicePath || context.outputDir;

    this.setContext({ coreInputs, confirmedValues, servicePath });

    // Build worker index content
    const content = this._buildWorkerIndex(coreInputs, confirmedValues);

    // Write file to src/worker/index.js
    await this.writeFile(join('src', 'worker', 'index.js'), content);

    // Return full path for backward compatibility
    return join(servicePath, 'src', 'worker', 'index.js');
  }

  /**
   * Build the complete worker index.js content
   * 
   * v4.4.1+: Generates code that imports directly from @tamyla/clodo-framework
   * using EnhancedRouter, composeMiddleware, createEnvironmentGuard, and
   * middleware factories — NOT the old MiddlewareRegistry/Composer pattern.
   */
  _buildWorkerIndex(coreInputs, confirmedValues) {
    const features = confirmedValues.features || {};
    const serviceName = coreInputs.serviceName;
    const serviceType = coreInputs.serviceType;

    // Determine which env bindings are required based on features
    const requiredBindings = [];
    const optionalBindings = ['DEBUG'];
    
    if (features.d1 || features.database) requiredBindings.push('DB');
    if (features.kv || features.upstash) requiredBindings.push('KV');
    if (features.r2) requiredBindings.push('R2_STORAGE');
    if (features.ai) requiredBindings.push('AI');
    if (features.vectorize) requiredBindings.push('VECTORIZE_INDEX');
    if (features.queues) requiredBindings.push('QUEUE');
    if (features.email) requiredBindings.push('EMAIL');
    if (features.hyperdrive) requiredBindings.push('HYPERDRIVE');
    if (features.durableObject || features.durableObjects) requiredBindings.push('DURABLE_OBJECT');

    // Build framework imports
    const frameworkImports = [
      'createEnhancedRouter',
      'createCorsMiddleware',
      'createErrorHandler',
      'createLogger',
      'composeMiddleware',
      'createEnvironmentGuard'
    ];
    if (features.rateLimiting) frameworkImports.push('createRateLimitGuard');

    // Build utility imports based on features
    const utilityImports = [];
    if (features.kv || features.upstash) utilityImports.push('getKV', 'putKV', 'listKV', 'deleteKV');
    if (features.r2) utilityImports.push('putR2Object', 'getR2Object');
    if (features.ai) utilityImports.push('runAIModel', 'streamAIResponse');

    // Build route stubs based on service type
    const routeStubs = this._buildRouteStubs(coreInputs, confirmedValues, features);

    // Build queue handler if queues feature is enabled
    const queueHandler = features.queues ? this._buildQueueHandler(serviceName) : '';

    // Build cron handler if cron feature is enabled
    const cronHandler = features.cron ? this._buildCronHandler(serviceName) : '';

    return `/**
 * ${confirmedValues.displayName} - Cloudflare Worker
 *
 * Generated by Clodo Framework v4.4.1
 * Service Type: ${serviceType}
 */

import {
  ${frameworkImports.join(',\n  ')}
} from '@tamyla/clodo-framework';
${utilityImports.length > 0 ? `\nimport { ${utilityImports.join(', ')} } from '@tamyla/clodo-framework/utilities';\n` : ''}
// ── Environment validation ────────────────────────────────────────────
const envGuard = createEnvironmentGuard({
  required: [${requiredBindings.map(b => `'${b}'`).join(', ')}],
  optional: [${optionalBindings.map(b => `'${b}'`).join(', ')}]
});

// ── Middleware stack ──────────────────────────────────────────────────
const middleware = composeMiddleware(
  createCorsMiddleware({ origins: ['*'] }),
  createLogger({ prefix: '${serviceName}', level: 'info' }),${features.rateLimiting ? `\n  createRateLimitGuard({ maxRequests: 100, windowMs: 60000 }),` : ''}
  createErrorHandler({ includeStack: false })
);

// ── Router ────────────────────────────────────────────────────────────
const router = createEnhancedRouter(${features.d1 || features.database ? 'null /* D1 injected per-request via env.DB */' : 'null'}, {
  autoRegisterGenericRoutes: false
});

// Health check
router.get('${confirmedValues.healthCheckPath || '/health'}', (c) => {
  return c.json({
    status: 'healthy',
    service: '${serviceName}',
    version: '${confirmedValues.version}',
    timestamp: new Date().toISOString()
  });
});

${routeStubs}

// ── Worker entry point ────────────────────────────────────────────────
export default {
  async fetch(request, env, ctx) {
    envGuard.check(env);
    const url = new URL(request.url);

    return middleware.execute(request, () =>
      router.handleRequest(request.method, url.pathname, request, env, ctx)
    );
  }${queueHandler}${cronHandler}
};
`;
  }

  /**
   * Generate route stubs based on service type and features
   */
  _buildRouteStubs(coreInputs, confirmedValues, features) {
    const apiBase = confirmedValues.apiBasePath || '/api/v1';
    const serviceType = coreInputs.serviceType;

    // REST API routes with KV
    if ((features.kv || features.upstash) && !features.d1) {
      return `// ── API Routes (KV-backed) ─────────────────────────────────────────────

router.get('${apiBase}/items', async (c) => {
  const list = await listKV(c.env.KV, { prefix: 'item:' });
  const items = await Promise.all(
    (list.keys || []).map(async (k) => getKV(c.env.KV, k.name, { type: 'json' }))
  );
  return c.json({ items: items.filter(Boolean), count: items.length });
});

router.get('${apiBase}/items/:id', async (c) => {
  const id = c.req.param('id');
  const item = await getKV(c.env.KV, \`item:\${id}\`, { type: 'json' });
  if (!item) return c.json({ error: 'Not found' }, 404);
  return c.json(item);
});

router.post('${apiBase}/items', async (c) => {
  const body = await c.req.json();
  const id = crypto.randomUUID();
  const item = { id, ...body, createdAt: new Date().toISOString() };
  await putKV(c.env.KV, \`item:\${id}\`, JSON.stringify(item));
  return c.json(item, 201);
});

router.put('${apiBase}/items/:id', async (c) => {
  const id = c.req.param('id');
  const existing = await getKV(c.env.KV, \`item:\${id}\`, { type: 'json' });
  if (!existing) return c.json({ error: 'Not found' }, 404);
  const body = await c.req.json();
  const updated = { ...existing, ...body, id, updatedAt: new Date().toISOString() };
  await putKV(c.env.KV, \`item:\${id}\`, JSON.stringify(updated));
  return c.json(updated);
});

router.delete('${apiBase}/items/:id', async (c) => {
  const id = c.req.param('id');
  await deleteKV(c.env.KV, \`item:\${id}\`);
  return c.json({ deleted: true, id });
});`;
    }

    // D1-backed routes
    if (features.d1 || features.database) {
      return `// ── API Routes (D1-backed) ─────────────────────────────────────────────

router.get('${apiBase}/items', async (c) => {
  const { results } = await c.env.DB.prepare('SELECT * FROM items ORDER BY created_at DESC LIMIT 50').all();
  return c.json({ items: results, count: results.length });
});

router.get('${apiBase}/items/:id', async (c) => {
  const id = c.req.param('id');
  const item = await c.env.DB.prepare('SELECT * FROM items WHERE id = ?').bind(id).first();
  if (!item) return c.json({ error: 'Not found' }, 404);
  return c.json(item);
});

router.post('${apiBase}/items', async (c) => {
  const body = await c.req.json();
  const id = crypto.randomUUID();
  await c.env.DB.prepare('INSERT INTO items (id, name, data, created_at) VALUES (?, ?, ?, ?)')
    .bind(id, body.name, JSON.stringify(body.data || {}), new Date().toISOString())
    .run();
  return c.json({ id, ...body, createdAt: new Date().toISOString() }, 201);
});

router.delete('${apiBase}/items/:id', async (c) => {
  const id = c.req.param('id');
  await c.env.DB.prepare('DELETE FROM items WHERE id = ?').bind(id).run();
  return c.json({ deleted: true, id });
});`;
    }

    // AI worker routes
    if (features.ai) {
      return `// ── AI Routes ─────────────────────────────────────────────────────────

router.post('${apiBase}/chat', async (c) => {
  const { messages, model } = await c.req.json();
  const result = await runAIModel(c.env.AI, model || '@cf/meta/llama-3.1-8b-instruct', {
    messages: messages || []
  });
  return c.json({ response: result.response });
});

router.post('${apiBase}/chat/stream', async (c) => {
  const { messages, model } = await c.req.json();
  const stream = await runAIModel(c.env.AI, model || '@cf/meta/llama-3.1-8b-instruct', {
    messages: messages || [], stream: true
  });
  return streamAIResponse(stream);
});

router.get('${apiBase}/models', (c) => {
  return c.json({
    models: [
      { name: 'llama-3.1-8b-instruct', type: 'chat' },
      { name: 'bge-base-en-v1.5', type: 'embeddings' }
    ]
  });
});`;
    }

    // Default minimal routes
    return `// ── API Routes ─────────────────────────────────────────────────────────

router.get('${apiBase}/status', (c) => {
  return c.json({
    service: '${coreInputs.serviceName}',
    status: 'running',
    timestamp: new Date().toISOString()
  });
});

// Add your routes here:
// router.get('${apiBase}/items', async (c) => { ... });
// router.post('${apiBase}/items', async (c) => { ... });`;
  }

  /**
   * Build queue consumer handler
   */
  _buildQueueHandler(serviceName) {
    return `,

  // Queue consumer handler
  async queue(batch, env, ctx) {
    console.log(\`[${serviceName}] Processing batch of \${batch.messages.length} messages\`);
    for (const message of batch.messages) {
      try {
        console.log('Processing:', message.body);
        // Add your message processing logic here
        message.ack();
      } catch (error) {
        console.error('Message processing failed:', error.message);
        message.retry();
      }
    }
  }`;
  }

  /**
   * Build cron/scheduled handler
   */
  _buildCronHandler(serviceName) {
    return `,

  // Scheduled (cron) handler
  async scheduled(event, env, ctx) {
    console.log(\`[${serviceName}] Cron triggered: \${event.cron} at \${new Date(event.scheduledTime).toISOString()}\`);
    // Add your scheduled job logic here
  }`;
  }

  /**
   * Validate context has required fields
   */
  validateContext(context) {
    const coreInputs = context.coreInputs || context;
    const confirmedValues = context.confirmedValues || context;

    const required = [
      { field: 'serviceName', source: coreInputs },
      { field: 'serviceType', source: coreInputs },
      { field: 'displayName', source: confirmedValues },
      { field: 'version', source: confirmedValues }
    ];

    const missing = required
      .filter(({ field, source }) => !source || !source[field])
      .map(({ field }) => field);

    if (missing.length > 0) {
      throw new Error(
        `WorkerIndexGenerator: Missing required fields: ${missing.join(', ')}`
      );
    }

    return true;
  }
}

