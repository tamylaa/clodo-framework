import { BaseGenerator } from '../BaseGenerator.js';
import { join } from 'path';
import { mkdirSync, writeFileSync } from 'fs';

/**
 * Service Utils Generator
 * Generates utility classes for database, validation, responses, logging, and features
 */
export class ServiceUtilsGenerator extends BaseGenerator {
  /**
   * Generate service utilities
   * @param {Object} context - Generation context
   * @returns {Promise<string>} Path to generated utils file
   */
  async generate(context) {
    const { coreInputs, confirmedValues, servicePath } = this.extractContext(context);
    
    if (!this.shouldGenerate(context)) {
      return null;
    }

    const utilsContent = `/**
 * ${confirmedValues.displayName} - Service Utilities
 *
 * Generated by Clodo Framework GenerationEngine
 * Service Type: ${coreInputs.serviceType}
 */

/**
 * Utility functions for ${confirmedValues.displayName}
 */

// Database utilities
export class DatabaseUtils {
  static async executeQuery(env, query, params = []) {
    try {
      const stmt = env.DB.prepare(query);
      if (params.length > 0) {
        return await stmt.bind(...params).all();
      }
      return await stmt.all();
    } catch (error) {
      console.error('Database query error:', error);
      throw new Error(\`Database operation failed: \${error.message}\`);
    }
  }

  static async getById(env, table, id) {
    const result = await this.executeQuery(
      env,
      \`SELECT * FROM \${table} WHERE id = ?\`,
      [id]
    );
    return result.results[0] || null;
  }

  static async create(env, table, data) {
    const columns = Object.keys(data).join(', ');
    const placeholders = Object.keys(data).map(() => '?').join(', ');
    const values = Object.values(data);

    const result = await this.executeQuery(
      env,
      \`INSERT INTO \${table} (\${columns}) VALUES (\${placeholders})\`,
      values
    );

    return result.meta.last_row_id;
  }

  static async update(env, table, id, data) {
    const setClause = Object.keys(data).map(key => \`\${key} = ?\`).join(', ');
    const values = [...Object.values(data), id];

    const result = await this.executeQuery(
      env,
      \`UPDATE \${table} SET \${setClause} WHERE id = ?\`,
      values
    );

    return result.meta.changes > 0;
  }

  static async delete(env, table, id) {
    const result = await this.executeQuery(
      env,
      \`DELETE FROM \${table} WHERE id = ?\`,
      [id]
    );

    return result.meta.changes > 0;
  }
}

// Validation utilities
export class ValidationUtils {
  static isValidUUID(uuid) {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegex.test(uuid);
  }

  static isValidEmail(email) {
    const emailRegex = /^[^@]+@[^@]+.[^@]+$/;
    return emailRegex.test(email);
  }

  static sanitizeString(str, maxLength = 1000) {
    if (typeof str !== 'string') return '';
    return str.trim().substring(0, maxLength);
  }

  static validatePagination(limit = 20, offset = 0) {
    const maxLimit = 100;
    const sanitizedLimit = Math.min(Math.max(1, limit), maxLimit);
    const sanitizedOffset = Math.max(0, offset);

    return { limit: sanitizedLimit, offset: sanitizedOffset };
  }
}

// Response utilities
export class ResponseUtils {
  static createSuccessResponse(data, status = 200) {
    return new Response(JSON.stringify({
      success: true,
      data,
      timestamp: new Date().toISOString()
    }), {
      status,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  static createErrorResponse(error, status = 500, details = null) {
    const errorResponse = {
      success: false,
      error: error.message || 'Internal Server Error',
      timestamp: new Date().toISOString()
    };

    if (details) {
      errorResponse.details = details;
    }

    return new Response(JSON.stringify(errorResponse), {
      status,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  static createPaginatedResponse(data, pagination, status = 200) {
    return new Response(JSON.stringify({
      success: true,
      data,
      pagination: {
        ...pagination,
        hasMore: data.length === pagination.limit
      },
      timestamp: new Date().toISOString()
    }), {
      status,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// Logging utilities
export class LoggingUtils {
  static logRequest(request, context = {}) {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      type: 'request',
      method: request.method,
      url: request.url,
      userAgent: request.headers.get('User-Agent'),
      ...context
    }));
  }

  static logError(error, context = {}) {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      type: 'error',
      message: error.message,
      stack: error.stack,
      ...context
    }));
  }

  static logPerformance(operation, startTime, context = {}) {
    const duration = Date.now() - startTime;
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      type: 'performance',
      operation,
      duration,
      ...context
    }));
  }
}

// Feature flag utilities
export class FeatureUtils {
  static isFeatureEnabled(featureName, serviceConfig) {
    return serviceConfig.features && serviceConfig.features[featureName] === true;
  }

  static getEnabledFeatures(serviceConfig) {
    if (!serviceConfig.features) return [];
    return Object.entries(serviceConfig.features)
      .filter(([, enabled]) => enabled)
      .map(([feature]) => feature);
  }

  static getDisabledFeatures(serviceConfig) {
    if (!serviceConfig.features) return [];
    return Object.entries(serviceConfig.features)
      .filter(([, enabled]) => !enabled)
      .map(([feature]) => feature);
  }
}
`;

    const filePath = join(servicePath, 'src', 'utils', 'service-utils.js');
    
    // Ensure directory exists
    const dir = join(servicePath, 'src', 'utils');
    mkdirSync(dir, { recursive: true });
    
    writeFileSync(filePath, utilsContent, 'utf8');
    this.logger.info(`Generated: ${filePath}`);
    
    return filePath;
  }

  /**
   * Determine if generator should run
   */
  shouldGenerate(context) {
    return true; // Always generate utils
  }
}
