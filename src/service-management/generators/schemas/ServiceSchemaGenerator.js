import { BaseGenerator } from '../BaseGenerator.js';
import { join } from 'path';

/**
 * ServiceSchemaGenerator
 * 
 * Generates src/schemas/service-schema.js with Zod schemas.
 */
export class ServiceSchemaGenerator extends BaseGenerator {
  constructor(options = {}) {
    super({
      name: 'ServiceSchemaGenerator',
      description: 'Generates service Zod schemas',
      outputPath: 'src/schemas/service-schema.js',
      ...options
    });
  }

  shouldGenerate(context) {
    return true;
  }

  async generate(context) {
    const coreInputs = context.coreInputs || context;
    const confirmedValues = context.confirmedValues || context;
    const servicePath = context.servicePath || context.outputDir;

    this.setContext({ coreInputs, confirmedValues, servicePath });

    const typeSchemas = this._generateTypeSpecificSchemas(coreInputs.serviceType);

    const content = `/**
 * ${confirmedValues.displayName} - Service Schema
 *
 * Generated by Clodo Framework GenerationEngine
 * Service Type: ${coreInputs.serviceType}
 */

import { z } from 'zod';

// Base service schema
export const baseServiceSchema = z.object({
  id: z.string().uuid(),
  createdAt: z.date(),
  updatedAt: z.date(),
  version: z.string().default('${confirmedValues.version}')
});

// Service-specific schemas based on type
${typeSchemas}

// Request/Response schemas
export const healthCheckResponseSchema = z.object({
  status: z.enum(['healthy', 'unhealthy']),
  timestamp: z.string().datetime(),
  service: z.string(),
  version: z.string(),
  environment: z.string()
});

export const errorResponseSchema = z.object({
  error: z.string(),
  message: z.string(),
  timestamp: z.string().datetime(),
  service: z.string(),
  version: z.string()
});

// Validation helpers
export function validateServiceRequest(data, schema) {
  try {
    return { success: true, data: schema.parse(data) };
  } catch (error) {
    return {
      success: false,
      error: error.errors.map(err => ({
        field: err.path.join('.'),
        message: err.message
      }))
    };
  }
}

export function createServiceResponse(data, schema) {
  try {
    return { success: true, data: schema.parse(data) };
  } catch (error) {
    throw new Error(\`Response validation failed: \${error.message}\`);
  }
}
`;

    await this.writeFile(join('src', 'schemas', 'service-schema.js'), content);
    return join(servicePath, 'src', 'schemas', 'service-schema.js');
  }

  _generateTypeSpecificSchemas(serviceType) {
    const schemas = {
      'data-service': `export const dataItemSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
  data: z.record(z.any()),
  tags: z.array(z.string()).optional(),
  status: z.enum(['active', 'inactive', 'archived']).default('active')
});

export const dataQuerySchema = z.object({
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0),
  search: z.string().optional(),
  filters: z.record(z.any()).optional(),
  sortBy: z.string().optional(),
  sortOrder: z.enum(['asc', 'desc']).default('asc')
});`,
      'auth-service': `export const userSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  username: z.string().min(3).max(50),
  displayName: z.string().min(1).max(100),
  roles: z.array(z.string()),
  isActive: z.boolean().default(true),
  lastLogin: z.date().optional(),
  emailVerified: z.boolean().default(false)
});

export const authTokenSchema = z.object({
  token: z.string(),
  type: z.enum(['access', 'refresh']),
  expiresAt: z.date(),
  userId: z.string().uuid(),
  scopes: z.array(z.string())
});`,
      'content-service': `export const contentItemSchema = z.object({
  id: z.string().uuid(),
  title: z.string().min(1).max(200),
  content: z.string(),
  contentType: z.enum(['article', 'page', 'media', 'document']),
  slug: z.string().min(1).max(100),
  author: z.string(),
  published: z.boolean().default(false),
  publishedAt: z.date().optional(),
  tags: z.array(z.string()),
  metadata: z.record(z.any())
});

export const mediaAssetSchema = z.object({
  id: z.string().uuid(),
  filename: z.string(),
  originalName: z.string(),
  mimeType: z.string(),
  size: z.number(),
  url: z.string(),
  thumbnailUrl: z.string().optional(),
  altText: z.string().optional()
});`,
      'api-gateway': `export const apiRouteSchema = z.object({
  path: z.string().regex(/^\\/.*/),
  method: z.enum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS']),
  targetService: z.string(),
  targetPath: z.string(),
  rateLimit: z.number().optional(),
  authentication: z.boolean().default(false),
  authorization: z.array(z.string()).optional()
});

export const apiMetricsSchema = z.object({
  route: z.string(),
  method: z.string(),
  responseTime: z.number(),
  statusCode: z.number(),
  timestamp: z.date(),
  userAgent: z.string().optional(),
  ipAddress: z.string().optional()
});`,
      'generic': `export const genericItemSchema = z.object({
  id: z.string().uuid(),
  type: z.string(),
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional()
});`
    };

    return schemas[serviceType] || schemas.generic;
  }

  validateContext(context) {
    const coreInputs = context.coreInputs || context;
    const confirmedValues = context.confirmedValues || context;

    if (!coreInputs.serviceType || !confirmedValues.version || !confirmedValues.displayName) {
      throw new Error('ServiceSchemaGenerator: Missing required fields');
    }

    return true;
  }
}
