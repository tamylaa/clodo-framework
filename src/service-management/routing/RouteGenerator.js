/**
 * RouteGenerator - Main orchestrator for route generation
 * 
 * Generates Cloudflare Workers [[routes]] configuration from domain metadata.
 * This is a CORE IDENTITY feature that completes multi-domain orchestration.
 * 
 * @module service-management/routing/RouteGenerator
 */

import { DomainRouteMapper } from './DomainRouteMapper.js';
import { WranglerRoutesBuilder } from './WranglerRoutesBuilder.js';
import { frameworkConfig } from '../../utils/framework-config.js';

export class RouteGenerator {
  constructor(options = {}) {
    this.mapper = new DomainRouteMapper(options);
    this.builder = new WranglerRoutesBuilder(options);
    
    // Load routing configuration from validation-config.json
    const routingConfig = frameworkConfig.getRoutingConfig();
    const templateDefaults = frameworkConfig.config.templates?.defaults || {};
    
    this.options = {
      // Routing defaults from config
      includeComments: routingConfig.defaults.includeComments,
      includeZoneId: routingConfig.defaults.includeZoneId,
      environment: routingConfig.defaults.targetEnvironment,  // Map targetEnvironment -> environment
      orderStrategy: routingConfig.defaults.orderStrategy,
      
      // Domain configuration
      workersDomain: templateDefaults.WORKERS_DEV_DOMAIN || 'workers.dev',
      skipPatterns: routingConfig.domains.skipPatterns,
      
      // Allow runtime overrides
      ...options
    };
  }

  /**
   * Generate routes configuration for wrangler.toml
   * 
   * @param {Object} coreInputs - Core service inputs (6 values)
   * @param {string} coreInputs.serviceName - Service name
   * @param {string} coreInputs.serviceType - Service type
   * @param {string} coreInputs.domainName - Domain name
   * @param {string} coreInputs.cloudflareAccountId - Cloudflare account ID
   * @param {string} coreInputs.cloudflareZoneId - Cloudflare zone ID (32 hex chars)
   * @param {string} coreInputs.environment - Environment (production|staging|development)
   * 
   * @param {Object} confirmedValues - Confirmed configuration values (15 values)
   * @param {string} confirmedValues.productionUrl - Production URL (e.g., api.example.com)
   * @param {string} confirmedValues.stagingUrl - Staging URL (e.g., staging-api.example.com)
   * @param {string} confirmedValues.developmentUrl - Development URL (optional, defaults to workers.dev)
   * @param {string} confirmedValues.apiBasePath - API base path (e.g., /api)
   * @param {string} confirmedValues.workerName - Worker name
   * 
   * @param {Object} options - Generation options
   * @param {boolean} options.includeComments - Include explanatory comments (default: true)
   * @param {boolean} options.includeZoneId - Include zone_id in routes (default: true)
   * @param {string} options.environment - Target environment filter (default: 'all')
   * 
   * @returns {string} TOML-formatted routes configuration
   * 
   * @throws {Error} If domain configuration is invalid or incomplete
   * 
   * @example
   * const routeGenerator = new RouteGenerator();
   * const routesConfig = routeGenerator.generateRoutes(
   *   {
   *     serviceName: 'my-api',
   *     domainName: 'example.com',
   *     cloudflareZoneId: 'abc123...',
   *     // ... other core inputs
   *   },
   *   {
   *     productionUrl: 'api.example.com',
   *     stagingUrl: 'staging-api.example.com',
   *     apiBasePath: '/api',
   *     // ... other confirmed values
   *   }
   * );
   */
  generateRoutes(coreInputs, confirmedValues, options = {}) {
    // Merge options
    const opts = { ...this.options, ...options };

    // Validate inputs
    this.validateDomainConfig(coreInputs, confirmedValues);

    // Build domain configuration
    const domainConfig = {
      domains: {
        production: confirmedValues.productionUrl,
        staging: confirmedValues.stagingUrl,
        development: confirmedValues.developmentUrl
      },
      zoneId: coreInputs.cloudflareZoneId,
      apiBasePath: confirmedValues.apiBasePath,
      serviceName: coreInputs.serviceName,
      workerName: confirmedValues.workerName
    };

    // Generate routes for each environment
    const productionRoutes = this._generateEnvironmentRoutes(
      domainConfig,
      'production',
      opts
    );

    const stagingRoutes = this._generateEnvironmentRoutes(
      domainConfig,
      'staging',
      opts
    );

    const developmentRoutes = this._generateEnvironmentRoutes(
      domainConfig,
      'development',
      opts
    );

    // Build complete routes section
    let routesSection = '';

    // Add header comment
    if (opts.includeComments) {
      routesSection += `# Routes configuration for ${domainConfig.serviceName}\n`;
      routesSection += `# Generated by Clodo Framework RouteGenerator\n`;
      routesSection += `# Generated: ${new Date().toISOString()}\n\n`;
    }

    // Add production routes (top-level)
    if (productionRoutes && (opts.environment === 'all' || opts.environment === 'production')) {
      routesSection += productionRoutes;
    }

    // Add staging routes
    if (stagingRoutes && (opts.environment === 'all' || opts.environment === 'staging')) {
      if (routesSection && !routesSection.endsWith('\n\n')) {
        routesSection += '\n';
      }
      routesSection += stagingRoutes;
    }

    // Add development routes (usually none - workers.dev)
    if (developmentRoutes && (opts.environment === 'all' || opts.environment === 'development')) {
      if (routesSection && !routesSection.endsWith('\n\n')) {
        routesSection += '\n';
      }
      routesSection += developmentRoutes;
    }

    return routesSection.trim() + '\n';
  }

  /**
   * Generate routes for a specific environment
   * @private
   */
  _generateEnvironmentRoutes(domainConfig, environment, options) {
    const domainUrl = domainConfig.domains[environment];

    // Skip if no domain configured or matches skip patterns
    if (!domainUrl || this._shouldSkipDomain(domainUrl)) {
      // workers.dev subdomain - no routes needed
      if (environment === 'development' && options.includeComments) {
        return this.builder.generateDevComment(domainConfig.workerName);
      }
      return '';
    }

    // Map domain to route patterns
    const routeMapping = this.mapper.mapDomainToRoutes(domainConfig, environment);

    // Build TOML routes section
    return this.builder.buildRoutesSection(
      routeMapping.patterns,
      environment,
      {
        zoneId: options.includeZoneId ? routeMapping.zoneId : null,
        includeComments: options.includeComments,
        domain: domainUrl,
        serviceName: domainConfig.serviceName
      }
    );
  }

  /**
   * Validate domain configuration completeness
   * 
   * @param {Object} coreInputs - Core service inputs
   * @param {Object} confirmedValues - Confirmed configuration values
   * @throws {Error} If validation fails
   */
  validateDomainConfig(coreInputs, confirmedValues) {
    // Check required coreInputs
    if (!coreInputs) {
      throw new Error('coreInputs is required for route generation');
    }

    if (!coreInputs.serviceName) {
      throw new Error('coreInputs.serviceName is required for route generation');
    }

    if (!coreInputs.cloudflareZoneId) {
      throw new Error('coreInputs.cloudflareZoneId is required for route generation');
    }

    // Validate zone_id format (32 hex characters)
    const zoneIdPattern = /^[a-f0-9]{32}$/;
    if (!zoneIdPattern.test(coreInputs.cloudflareZoneId)) {
      throw new Error(
        'coreInputs.cloudflareZoneId must be a valid Cloudflare zone ID (32 hex characters). ' +
        `Received: "${coreInputs.cloudflareZoneId}"`
      );
    }

    // Check required confirmedValues
    if (!confirmedValues) {
      throw new Error('confirmedValues is required for route generation');
    }

    if (!confirmedValues.productionUrl) {
      throw new Error('confirmedValues.productionUrl is required for route generation');
    }

    // Validate production URL format
    if (!this._isValidDomain(confirmedValues.productionUrl)) {
      throw new Error(
        'confirmedValues.productionUrl must be a valid domain name. ' +
        `Received: "${confirmedValues.productionUrl}"`
      );
    }
  }

  /**
   * Check if a string is a valid domain name
   * @private
   */
  _isValidDomain(domain) {
    if (!domain || typeof domain !== 'string') {
      return false;
    }

    // Basic domain validation
    const domainPattern = /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?(\.[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    return domainPattern.test(domain);
  }

  /**
   * Get route patterns for a specific domain and environment
   * 
   * @param {string} domain - Domain name (e.g., api.example.com)
   * @param {string} environment - Environment (production|staging|development)
   * @param {Object} options - Additional options
   * @returns {Array<string>} Array of route patterns
   * 
   * @example
   * const patterns = routeGenerator.getRoutePatterns('api.example.com', 'production');
   * // Returns: ['api.example.com/*', 'example.com/api/*']
   */
  getRoutePatterns(domain, environment, options = {}) {
    const domainConfig = {
      domains: { [environment]: domain },
      zoneId: options.zoneId || 'placeholder',
      apiBasePath: options.apiBasePath,
      serviceName: options.serviceName || 'service'
    };

    const routeMapping = this.mapper.mapDomainToRoutes(domainConfig, environment);
    return routeMapping.patterns;
  }

  /**
   * Check if a domain should be skipped for route generation
   * @private
   * 
   * @param {string} domain - Domain to check
   * @returns {boolean} True if domain should be skipped
   */
  _shouldSkipDomain(domain) {
    if (!domain) return true;
    
    // Check workers.dev domain
    if (domain.includes(this.options.workersDomain)) {
      return true;
    }
    
    // Check configured skip patterns
    const skipPatterns = this.options.skipPatterns || [];
    return skipPatterns.some(pattern => domain.includes(pattern));
  }
}

