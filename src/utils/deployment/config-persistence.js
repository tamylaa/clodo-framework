/**
 * Configuration Persistence Manager
 * Saves deployment configurations to customer config files for reuse
 * 
 * This eliminates developer friction by:
 * - Saving all deployment inputs after successful deployment
 * - Auto-loading configurations for repeat deployments
 * - Eliminating re-entry of account IDs, zone IDs, URLs, etc.
 */

import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// ESM-compatible __dirname and __filename
let __dirname;
let __filename;

try {
  __filename = fileURLToPath(import.meta.url);
  __dirname = dirname(__filename);
} catch {
  // Fallback for test environments
  __dirname = process.cwd();
  __filename = __filename || 'config-persistence.js';
}

/**
 * ConfigPersistenceManager
 * Handles saving and loading deployment configurations
 */
export class ConfigPersistenceManager {
  constructor(options = {}) {
    // Default to config/customers in the target service directory
    this.configDir = options.configDir || join(process.cwd(), 'config', 'customers');
  }

  /**
   * Save deployment configuration to customer environment file
   * @param {Object} deployment - Complete deployment configuration
   * @param {string} deployment.customer - Customer name
   * @param {string} deployment.environment - Environment (development/staging/production)
   * @param {Object} deployment.coreInputs - Tier 1 core inputs
   * @param {Object} deployment.confirmations - Tier 2 confirmations
   * @param {Object} deployment.result - Deployment result
   */
  async saveDeploymentConfig(deployment) {
    const { customer, environment, coreInputs, confirmations, result } = deployment;

    if (!customer || !environment) {
      throw new Error('Customer and environment are required');
    }

    // Create customer directory if it doesn't exist
    const customerDir = join(this.configDir, customer);
    if (!existsSync(customerDir)) {
      mkdirSync(customerDir, { recursive: true });
    }

    // Generate environment file content
    const envContent = this.generateEnvFileContent({
      customer,
      environment,
      coreInputs,
      confirmations,
      result
    });

    // Write to customer environment file
    const envFile = join(customerDir, `${environment}.env`);
    writeFileSync(envFile, envContent, 'utf8');

    console.log(`   💾 Configuration saved: ${envFile}`);

    return envFile;
  }

  /**
   * Generate .env file content from deployment data
   * @param {Object} data - Deployment data
   * @returns {string} .env file content
   */
  generateEnvFileContent(data) {
    const { customer, environment, coreInputs, confirmations, result } = data;
    const timestamp = new Date().toISOString();

    const lines = [
      `# Deployment Configuration - ${customer} (${environment})`,
      `# Last Updated: ${timestamp}`,
      `# Auto-generated by Clodo Framework deployment`,
      '',
      '# ============================================',
      '# Core Customer Identity',
      '# ============================================',
      `CUSTOMER_ID=${customer}`,
      `CUSTOMER_NAME=${customer}`,
      `ENVIRONMENT=${environment}`,
      ''
    ];

    // Cloudflare Configuration
    if (coreInputs.cloudflareAccountId || coreInputs.cloudflareZoneId) {
      lines.push('# ============================================');
      lines.push('# Cloudflare Configuration');
      lines.push('# ============================================');
      
      if (coreInputs.cloudflareAccountId) {
        lines.push(`CLOUDFLARE_ACCOUNT_ID=${coreInputs.cloudflareAccountId}`);
      }
      if (coreInputs.cloudflareZoneId) {
        lines.push(`CLOUDFLARE_ZONE_ID=${coreInputs.cloudflareZoneId}`);
      }
      if (coreInputs.domainName) {
        lines.push(`CUSTOMER_DOMAIN=${coreInputs.domainName}`);
        lines.push(`DOMAIN=${coreInputs.domainName}`);
      }
      lines.push('# CLOUDFLARE_API_TOKEN=<stored-securely-in-env>');
      lines.push('');
    }

    // Service Configuration
    lines.push('# ============================================');
    lines.push('# Service Configuration');
    lines.push('# ============================================');
    
    if (coreInputs.serviceName) {
      lines.push(`SERVICE_NAME=${coreInputs.serviceName}`);
    }
    if (coreInputs.serviceType) {
      lines.push(`SERVICE_TYPE=${coreInputs.serviceType}`);
    }
    if (confirmations.displayName) {
      lines.push(`DISPLAY_NAME=${confirmations.displayName}`);
    }
    if (confirmations.description) {
      lines.push(`DESCRIPTION=${confirmations.description}`);
    }
    if (confirmations.version) {
      lines.push(`VERSION=${confirmations.version}`);
    }
    if (confirmations.author) {
      lines.push(`AUTHOR=${confirmations.author}`);
    }
    lines.push('');

    // Database & Worker
    if (confirmations.databaseName || confirmations.workerName) {
      lines.push('# ============================================');
      lines.push('# Cloudflare Resources');
      lines.push('# ============================================');
      
      if (confirmations.workerName) {
        lines.push(`WORKER_NAME=${confirmations.workerName}`);
      }
      if (confirmations.databaseName) {
        lines.push(`DATABASE_NAME=${confirmations.databaseName}`);
        lines.push(`D1_DATABASE_NAME=${confirmations.databaseName}`);
      }
      lines.push('');
    }

    // URLs & Endpoints
    if (confirmations.productionUrl || confirmations.stagingUrl || confirmations.developmentUrl) {
      lines.push('# ============================================');
      lines.push('# Environment URLs');
      lines.push('# ============================================');
      
      if (confirmations.productionUrl) {
        lines.push(`PRODUCTION_URL=${confirmations.productionUrl}`);
      }
      if (confirmations.stagingUrl) {
        lines.push(`STAGING_URL=${confirmations.stagingUrl}`);
      }
      if (confirmations.developmentUrl) {
        lines.push(`DEVELOPMENT_URL=${confirmations.developmentUrl}`);
      }
      if (confirmations.documentationUrl) {
        lines.push(`DOCUMENTATION_URL=${confirmations.documentationUrl}`);
      }
      if (confirmations.deploymentUrl) {
        lines.push(`DEPLOYMENT_URL=${confirmations.deploymentUrl}`);
      }
      if (result && result.url) {
        lines.push(`API_URL=${result.url}`);
      }
      lines.push('');
    }

    // API Configuration
    if (confirmations.packageName || confirmations.apiBasePath || confirmations.healthCheckPath) {
      lines.push('# ============================================');
      lines.push('# API Configuration');
      lines.push('# ============================================');
      
      if (confirmations.packageName) {
        lines.push(`PACKAGE_NAME=${confirmations.packageName}`);
      }
      if (confirmations.apiBasePath) {
        lines.push(`API_BASE_PATH=${confirmations.apiBasePath}`);
      }
      if (confirmations.healthCheckPath) {
        lines.push(`HEALTH_CHECK_PATH=${confirmations.healthCheckPath}`);
      }
      lines.push(`API_VERSION=v1`);
      lines.push('');
    }

    // Feature Flags
    if (confirmations.features && Object.keys(confirmations.features).length > 0) {
      lines.push('# ============================================');
      lines.push('# Feature Flags');
      lines.push('# ============================================');
      
      Object.entries(confirmations.features).forEach(([feature, enabled]) => {
        const featureName = feature.toUpperCase().replace(/([A-Z])/g, '_$1').replace(/^_/, '');
        lines.push(`FEATURE_${featureName}=${enabled ? 'true' : 'false'}`);
      });
      lines.push('');
    }

    // Environment-specific settings
    lines.push('# ============================================');
    lines.push(`# ${environment.charAt(0).toUpperCase() + environment.slice(1)} Environment Settings`);
    lines.push('# ============================================');
    
    switch (environment) {
      case 'development':
        lines.push('ENABLE_DEBUG_MODE=true');
        lines.push('ENABLE_DETAILED_LOGGING=true');
        lines.push('LOG_LEVEL=debug');
        lines.push('RATE_LIMIT_REQUESTS_PER_MINUTE=10000');
        lines.push('CORS_ORIGINS=*');
        break;
      case 'staging':
        lines.push('ENABLE_DEBUG_MODE=true');
        lines.push('LOG_LEVEL=info');
        lines.push('RATE_LIMIT_REQUESTS_PER_MINUTE=1000');
        break;
      case 'production':
        lines.push('ENABLE_DEBUG_MODE=false');
        lines.push('LOG_LEVEL=warn');
        lines.push('RATE_LIMIT_REQUESTS_PER_MINUTE=60');
        lines.push('# Add production-specific secrets via Cloudflare dashboard or wrangler');
        break;
    }
    lines.push('');

    // Monitoring
    lines.push('# ============================================');
    lines.push('# Monitoring & Observability');
    lines.push('# ============================================');
    lines.push('METRICS_ENABLED=true');
    lines.push('TRACING_ENABLED=true');
    lines.push('ERROR_REPORTING_ENABLED=true');
    lines.push('');

    // Deployment metadata
    lines.push('# ============================================');
    lines.push('# Deployment Metadata');
    lines.push('# ============================================');
    lines.push(`DEPLOYED_AT=${timestamp}`);
    if (result && result.status) {
      lines.push(`DEPLOYMENT_STATUS=${result.status}`);
    }
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Check if customer configuration exists
   * @param {string} customer - Customer name
   * @param {string} environment - Environment
   * @returns {boolean} True if configuration exists
   */
  configExists(customer, environment) {
    const envFile = join(this.configDir, customer, `${environment}.env`);
    return existsSync(envFile);
  }

  /**
   * Get all configured customers
   * @returns {Array<string>} List of customer names
   */
  getConfiguredCustomers() {
    if (!existsSync(this.configDir)) {
      return [];
    }

    const fs = require('fs');
    const entries = fs.readdirSync(this.configDir, { withFileTypes: true });
    
    return entries
      .filter(entry => entry.isDirectory() && entry.name !== 'template')
      .map(entry => entry.name);
  }

  /**
   * Load environment file and parse into object
   * @param {string} customer - Customer name
   * @param {string} environment - Environment
   * @returns {Object|null} Parsed environment variables or null if not found
   */
  loadEnvironmentConfig(customer, environment) {
    const envFile = join(this.configDir, customer, `${environment}.env`);
    
    if (!existsSync(envFile)) {
      return null;
    }

    const content = readFileSync(envFile, 'utf8');
    const envVars = {};

    content.split('\n').forEach(line => {
      line = line.trim();
      
      // Skip comments and empty lines
      if (!line || line.startsWith('#')) {
        return;
      }

      // Parse KEY=value
      const match = line.match(/^([A-Z_][A-Z0-9_]*)=(.*)$/);
      if (match) {
        const [, key, value] = match;
        envVars[key] = value;
      }
    });

    return envVars;
  }

  /**
   * Display customer configuration summary
   * @param {string} customer - Customer name
   * @param {string} environment - Environment
   */
  displayCustomerConfig(customer, environment) {
    const config = this.loadEnvironmentConfig(customer, environment);
    
    if (!config) {
      console.log(`   ⚠️  No configuration found for ${customer}/${environment}`);
      return;
    }

    console.log(`\n   📋 Existing Configuration for ${customer}/${environment}:`);
    console.log('   ' + '─'.repeat(60));
    
    const highlights = [
      'CUSTOMER_DOMAIN',
      'CLOUDFLARE_ACCOUNT_ID',
      'CLOUDFLARE_ZONE_ID',
      'SERVICE_NAME',
      'WORKER_NAME',
      'DATABASE_NAME',
      'DEPLOYMENT_URL',
      'DEPLOYED_AT'
    ];

    highlights.forEach(key => {
      if (config[key]) {
        let value = config[key];
        
        // Truncate long IDs for display
        if (key.includes('_ID') && value.length > 20) {
          value = value.substring(0, 8) + '...' + value.substring(value.length - 4);
        }
        
        console.log(`   ${key.padEnd(25)}: ${value}`);
      }
    });
    
    console.log('   ' + '─'.repeat(60));
  }
}

// Export singleton instance for convenience
export const configPersistence = new ConfigPersistenceManager();
